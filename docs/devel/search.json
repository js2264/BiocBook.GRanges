[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Tidy GenomicRanges (from Michael Love)",
    "section": "",
    "text": "Welcome\nPackage: BiocBook.GRangesAuthors: Michael Love [aut], Jacques Serizay [com, cre]Compiled: 2023-08-12Package version: 0.99.0R version: R version 4.3.1 (2023-06-16)BioC version: 3.18License: MIT + file LICENSE\nThis is the landing page of the BiocBook entitled Tidy GenomicRanges in R. This book compiles material put together by Michael Love.\nThese examples focus on the packages dplyr, plyranges, nullranges, excluderanges, as well as tidy transcriptomics packages such as tidybulk and tidySummarizedExperiment.\nDocker image\nA Docker image built from this repository is available here:\nüëâ ghcr.io/js2264/biocbook.granges üê≥\n\n\n\n\n\n\nGet started now üéâ\n\n\n\nYou can get access to all the packages used in this book in &lt; 1 minute, using this command in a terminal:\n\n\n\nbash\n\ndocker run -it ghcr.io/js2264/biocbook.granges:devel R\n\n\n\n\nRStudio Server\nAn RStudio Server instance can be initiated from the Docker image as follows:\n\n\n\nbash\n\ndocker run \\\n    --volume &lt;local_folder&gt;:&lt;destination_folder&gt; \\\n    -e PASSWORD=OHCA \\\n    -p 8787:8787 \\\n    ghcr.io/js2264/biocbook.granges:devel\n\n\nThe initiated RStudio Server instance will be available at https://localhost:8787.\nSession info\n\n\n\n\n\n\nClick to expand üëá\n\n\n\n\n\n\nsessioninfo::session_info(\n    installed.packages()[,\"Package\"], \n    include_base = TRUE\n)\n##  ‚îÄ Session info ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n##   setting  value\n##   version  R version 4.3.1 (2023-06-16)\n##   os       Ubuntu 22.04.2 LTS\n##   system   x86_64, linux-gnu\n##   ui       X11\n##   language (EN)\n##   collate  en_US.UTF-8\n##   ctype    en_US.UTF-8\n##   tz       Etc/UTC\n##   date     2023-08-12\n##   pandoc   3.1.1 @ /usr/local/bin/ (via rmarkdown)\n##  \n##  ‚îÄ Packages ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n##   package                           * version    date (UTC) lib source\n##   abind                               1.4-5      2016-07-21 [1] CRAN (R 4.3.1)\n##   AnnotationDbi                       1.63.2     2023-07-02 [1] Bioconductor\n##   AnnotationFilter                    1.25.0     2023-04-25 [1] Bioconductor\n##   AnnotationHub                       3.9.1      2023-05-01 [1] Bioconductor\n##   askpass                             1.1        2019-01-13 [1] CRAN (R 4.3.1)\n##   available                           1.1.0      2022-07-10 [1] CRAN (R 4.3.1)\n##   base                              * 4.3.1      2023-08-10 [2] local\n##   base64enc                           0.1-3      2015-07-28 [1] CRAN (R 4.3.1)\n##   BH                                  1.81.0-1   2023-01-22 [1] CRAN (R 4.3.1)\n##   Biobase                             2.61.0     2023-04-25 [1] Bioconductor\n##   BiocBook                            0.99.0     2023-08-12 [1] Github (js2264/BiocBook@1ef3442)\n##   BiocBook.GRanges                    0.99.0     2023-08-12 [1] local\n##   BiocFileCache                       2.9.1      2023-07-12 [1] Bioconductor\n##   BiocGenerics                        0.47.0     2023-04-25 [1] Bioconductor\n##   BiocIO                              1.11.0     2023-04-25 [1] Bioconductor\n##   BiocManager                         1.30.22    2023-08-08 [1] CRAN (R 4.3.1)\n##   BiocParallel                        1.35.3     2023-07-07 [1] Bioconductor\n##   BiocStyle                           2.29.1     2023-07-19 [1] Bioconductor\n##   BiocVersion                         3.18.0     2023-04-25 [1] Bioconductor\n##   biomaRt                             2.57.1     2023-06-09 [1] Bioconductor\n##   Biostrings                          2.69.2     2023-07-02 [1] Bioconductor\n##   bit                                 4.0.5      2022-11-15 [1] CRAN (R 4.3.1)\n##   bit64                               4.0.5      2020-08-30 [1] CRAN (R 4.3.1)\n##   bitops                              1.0-7      2021-04-24 [1] CRAN (R 4.3.1)\n##   blob                                1.2.4      2023-03-17 [1] CRAN (R 4.3.1)\n##   bookdown                            0.35       2023-08-09 [1] CRAN (R 4.3.1)\n##   boot                                1.3-28.1   2022-11-22 [2] CRAN (R 4.3.1)\n##   bootstrap                           2019.6     2019-06-17 [1] CRAN (R 4.3.1)\n##   brew                                1.0-8      2022-09-29 [1] CRAN (R 4.3.1)\n##   brio                                1.1.3      2021-11-30 [1] CRAN (R 4.3.1)\n##   bslib                               0.5.1      2023-08-11 [1] CRAN (R 4.3.1)\n##   cachem                              1.0.8      2023-05-01 [1] CRAN (R 4.3.1)\n##   callr                               3.7.3      2022-11-02 [1] CRAN (R 4.3.1)\n##   class                               7.3-22     2023-05-03 [2] CRAN (R 4.3.1)\n##   cli                                 3.6.1      2023-03-23 [1] CRAN (R 4.3.1)\n##   clipr                               0.8.0      2022-02-22 [1] CRAN (R 4.3.1)\n##   clisymbols                          1.2.0      2017-05-21 [1] CRAN (R 4.3.1)\n##   cluster                             2.1.4      2022-08-22 [2] CRAN (R 4.3.1)\n##   CodeDepends                         0.6.5      2018-07-17 [1] CRAN (R 4.3.1)\n##   codetools                           0.2-19     2023-02-01 [2] CRAN (R 4.3.1)\n##   colorspace                          2.1-0      2023-01-23 [1] CRAN (R 4.3.1)\n##   commonmark                          1.9.0      2023-03-17 [1] CRAN (R 4.3.1)\n##   compiler                            4.3.1      2023-08-10 [2] local\n##   cpp11                               0.4.6      2023-08-10 [1] CRAN (R 4.3.1)\n##   crayon                              1.5.2      2022-09-29 [1] CRAN (R 4.3.1)\n##   credentials                         1.3.2      2021-11-29 [1] CRAN (R 4.3.1)\n##   crosstalk                           1.2.0      2021-11-04 [1] CRAN (R 4.3.1)\n##   curl                                5.0.1      2023-06-07 [1] CRAN (R 4.3.1)\n##   data.table                          1.14.8     2023-02-17 [1] CRAN (R 4.3.1)\n##   datasets                          * 4.3.1      2023-08-10 [2] local\n##   DBI                                 1.1.3      2022-06-18 [1] CRAN (R 4.3.1)\n##   dbplyr                              2.3.3      2023-07-07 [1] CRAN (R 4.3.1)\n##   DelayedArray                        0.27.10    2023-07-28 [1] Bioconductor\n##   desc                                1.4.2      2022-09-08 [1] CRAN (R 4.3.1)\n##   DESeq2                              1.41.6     2023-07-24 [1] Bioconductor\n##   devtools                            2.4.5      2022-10-11 [1] CRAN (R 4.3.1)\n##   diffobj                             0.3.5      2021-10-05 [1] CRAN (R 4.3.1)\n##   digest                              0.6.33     2023-07-07 [1] CRAN (R 4.3.1)\n##   dir.expiry                          1.9.0      2023-04-25 [1] Bioconductor\n##   docopt                              0.7.1      2020-06-24 [1] CRAN (R 4.3.1)\n##   downlit                             0.4.3      2023-06-29 [1] CRAN (R 4.3.1)\n##   dplyr                               1.1.2      2023-04-20 [1] CRAN (R 4.3.1)\n##   DT                                  0.28       2023-05-18 [1] CRAN (R 4.3.1)\n##   edgeR                               3.43.8     2023-08-02 [1] Bioconductor\n##   ellipsis                            0.3.2      2021-04-29 [1] CRAN (R 4.3.1)\n##   ensembldb                           2.25.0     2023-04-25 [1] Bioconductor\n##   evaluate                            0.21       2023-05-05 [1] CRAN (R 4.3.1)\n##   fansi                               1.0.4      2023-01-22 [1] CRAN (R 4.3.1)\n##   farver                              2.1.1      2022-07-06 [1] CRAN (R 4.3.1)\n##   fastmap                             1.1.1      2023-02-24 [1] CRAN (R 4.3.1)\n##   filelock                            1.0.2      2018-10-05 [1] CRAN (R 4.3.1)\n##   fission                             1.21.0     2023-04-27 [1] Bioconductor\n##   fontawesome                         0.5.1      2023-04-18 [1] CRAN (R 4.3.1)\n##   foreach                             1.5.2      2022-02-02 [1] CRAN (R 4.3.1)\n##   foreign                             0.8-84     2022-12-06 [2] CRAN (R 4.3.1)\n##   formatR                             1.14       2023-01-17 [1] CRAN (R 4.3.1)\n##   fs                                  1.6.3      2023-07-20 [1] CRAN (R 4.3.1)\n##   futile.logger                       1.4.3      2016-07-10 [1] CRAN (R 4.3.1)\n##   futile.options                      1.0.1      2018-04-20 [1] CRAN (R 4.3.1)\n##   generics                            0.1.3      2022-07-05 [1] CRAN (R 4.3.1)\n##   GenomeInfoDb                        1.37.2     2023-06-21 [1] Bioconductor\n##   GenomeInfoDbData                    1.2.10     2023-08-12 [1] Bioconductor\n##   GenomicAlignments                   1.37.0     2023-04-25 [1] Bioconductor\n##   GenomicFeatures                     1.53.1     2023-06-22 [1] Bioconductor\n##   GenomicRanges                       1.53.1     2023-05-04 [1] Bioconductor\n##   gert                                1.9.3      2023-08-07 [1] CRAN (R 4.3.1)\n##   ggplot2                             3.4.2      2023-04-03 [1] CRAN (R 4.3.1)\n##   ggplotify                           0.1.2      2023-08-09 [1] CRAN (R 4.3.1)\n##   ggrepel                             0.9.3      2023-02-03 [1] CRAN (R 4.3.1)\n##   ggridges                            0.5.4      2022-09-26 [1] CRAN (R 4.3.1)\n##   gh                                  1.4.0      2023-02-22 [1] CRAN (R 4.3.1)\n##   gitcreds                            0.1.2      2022-09-08 [1] CRAN (R 4.3.1)\n##   glmnet                              4.1-7      2023-03-23 [1] CRAN (R 4.3.1)\n##   glue                                1.6.2      2022-02-24 [1] CRAN (R 4.3.1)\n##   graph                               1.79.0     2023-04-25 [1] Bioconductor\n##   graphics                          * 4.3.1      2023-08-10 [2] local\n##   grDevices                         * 4.3.1      2023-08-10 [2] local\n##   grid                                4.3.1      2023-08-10 [2] local\n##   gridGraphics                        0.5-1      2020-12-13 [1] CRAN (R 4.3.1)\n##   gtable                              0.3.3      2023-03-21 [1] CRAN (R 4.3.1)\n##   highr                               0.10       2022-12-22 [1] CRAN (R 4.3.1)\n##   hms                                 1.1.3      2023-03-21 [1] CRAN (R 4.3.1)\n##   htmltools                           0.5.6      2023-08-10 [1] CRAN (R 4.3.1)\n##   htmlwidgets                         1.6.2      2023-03-17 [1] CRAN (R 4.3.1)\n##   httpuv                              1.6.11     2023-05-11 [1] CRAN (R 4.3.1)\n##   httr                                1.4.6      2023-05-08 [1] CRAN (R 4.3.1)\n##   httr2                               0.2.3      2023-05-08 [1] CRAN (R 4.3.1)\n##   ini                                 0.3.1      2018-05-20 [1] CRAN (R 4.3.1)\n##   InteractionSet                      1.29.1     2023-06-14 [1] Bioconductor\n##   interactiveDisplayBase              1.39.0     2023-04-25 [1] Bioconductor\n##   IRanges                             2.35.2     2023-06-22 [1] Bioconductor\n##   isoband                             0.2.7      2022-12-20 [1] CRAN (R 4.3.1)\n##   iterators                           1.0.14     2022-02-05 [1] CRAN (R 4.3.1)\n##   janeaustenr                         1.0.0      2022-08-26 [1] CRAN (R 4.3.1)\n##   jquerylib                           0.1.4      2021-04-26 [1] CRAN (R 4.3.1)\n##   jsonlite                            1.8.7      2023-06-29 [1] CRAN (R 4.3.1)\n##   KEGGREST                            1.41.0     2023-04-25 [1] Bioconductor\n##   KernSmooth                          2.23-22    2023-07-10 [1] CRAN (R 4.3.1)\n##   knitr                               1.43       2023-05-25 [1] CRAN (R 4.3.1)\n##   labeling                            0.4.2      2020-10-20 [1] CRAN (R 4.3.1)\n##   lambda.r                            1.2.4      2019-09-18 [1] CRAN (R 4.3.1)\n##   later                               1.3.1      2023-05-02 [1] CRAN (R 4.3.1)\n##   lattice                             0.21-8     2023-04-05 [2] CRAN (R 4.3.1)\n##   lazyeval                            0.2.2      2019-03-15 [1] CRAN (R 4.3.1)\n##   lifecycle                           1.0.3      2022-10-07 [1] CRAN (R 4.3.1)\n##   limma                               3.57.7     2023-08-02 [1] Bioconductor\n##   littler                             0.3.18     2023-03-26 [1] CRAN (R 4.3.1)\n##   locfit                              1.5-9.8    2023-06-11 [1] CRAN (R 4.3.1)\n##   macrophage                          1.17.0     2023-04-27 [1] Bioconductor\n##   magrittr                            2.0.3      2022-03-30 [1] CRAN (R 4.3.1)\n##   MASS                                7.3-60     2023-05-04 [2] CRAN (R 4.3.1)\n##   Matrix                              1.6-0      2023-07-08 [1] CRAN (R 4.3.1)\n##   MatrixGenerics                      1.13.1     2023-07-25 [1] Bioconductor\n##   matrixStats                         1.0.0      2023-06-02 [1] CRAN (R 4.3.1)\n##   memoise                             2.0.1      2021-11-26 [1] CRAN (R 4.3.1)\n##   methods                           * 4.3.1      2023-08-10 [2] local\n##   mgcv                                1.9-0      2023-07-11 [1] CRAN (R 4.3.1)\n##   mime                                0.12       2021-09-28 [1] CRAN (R 4.3.1)\n##   miniUI                              0.1.1.1    2018-05-18 [1] CRAN (R 4.3.1)\n##   munsell                             0.5.0      2018-06-12 [1] CRAN (R 4.3.1)\n##   nlme                                3.1-163    2023-08-09 [1] CRAN (R 4.3.1)\n##   nnet                                7.3-19     2023-05-03 [2] CRAN (R 4.3.1)\n##   nullranges                          1.7.9      2023-08-06 [1] Bioconductor\n##   oct4                                1.17.0     2023-04-27 [1] Bioconductor\n##   openssl                             2.1.0      2023-07-15 [1] CRAN (R 4.3.1)\n##   org.Hs.eg.db                        3.17.0     2023-08-12 [1] Bioconductor\n##   org.Mm.eg.db                        3.17.0     2023-08-12 [1] Bioconductor\n##   packrat                             0.9.1      2023-02-27 [1] CRAN (R 4.3.1)\n##   pak                                 0.5.1.9000 2023-08-02 [1] local\n##   parallel                            4.3.1      2023-08-10 [2] local\n##   pillar                              1.9.0      2023-03-22 [1] CRAN (R 4.3.1)\n##   pkgbuild                            1.4.2      2023-06-26 [1] CRAN (R 4.3.1)\n##   pkgconfig                           2.0.3      2019-09-22 [1] CRAN (R 4.3.1)\n##   pkgdown                             2.0.7      2022-12-14 [1] CRAN (R 4.3.1)\n##   pkgload                             1.3.2.1    2023-07-08 [1] CRAN (R 4.3.1)\n##   plogr                               0.2.0      2018-03-25 [1] CRAN (R 4.3.1)\n##   plotgardener                        1.7.7      2023-08-04 [1] Bioconductor\n##   plotly                              4.10.2     2023-06-03 [1] CRAN (R 4.3.1)\n##   plyranges                           1.21.0     2023-04-25 [1] Bioconductor\n##   png                                 0.1-8      2022-11-29 [1] CRAN (R 4.3.1)\n##   praise                              1.0.0      2015-08-11 [1] CRAN (R 4.3.1)\n##   preprocessCore                      1.63.1     2023-05-02 [1] Bioconductor\n##   prettyunits                         1.1.1      2020-01-24 [1] CRAN (R 4.3.1)\n##   processx                            3.8.2      2023-06-30 [1] CRAN (R 4.3.1)\n##   profvis                             0.3.8      2023-05-02 [1] CRAN (R 4.3.1)\n##   progress                            1.2.2      2019-05-16 [1] CRAN (R 4.3.1)\n##   promises                            1.2.1      2023-08-10 [1] CRAN (R 4.3.1)\n##   ProtGenerics                        1.33.1     2023-06-16 [1] Bioconductor\n##   ps                                  1.7.5      2023-04-18 [1] CRAN (R 4.3.1)\n##   purrr                               1.0.2      2023-08-10 [1] CRAN (R 4.3.1)\n##   quarto                              1.2        2022-07-06 [1] CRAN (R 4.3.1)\n##   R6                                  2.5.1      2021-08-19 [1] CRAN (R 4.3.1)\n##   ragg                                1.2.5      2023-01-12 [1] CRAN (R 4.3.1)\n##   randomNames                         1.5-0.0    2021-04-22 [1] CRAN (R 4.3.1)\n##   rappdirs                            0.3.3      2021-01-31 [1] CRAN (R 4.3.1)\n##   rcmdcheck                           1.4.0      2021-09-27 [1] CRAN (R 4.3.1)\n##   RColorBrewer                        1.1-3      2022-04-03 [1] CRAN (R 4.3.1)\n##   Rcpp                                1.0.11     2023-07-06 [1] CRAN (R 4.3.1)\n##   RcppArmadillo                       0.12.6.1.0 2023-08-10 [1] CRAN (R 4.3.1)\n##   RcppEigen                           0.3.3.9.3  2022-11-05 [1] CRAN (R 4.3.1)\n##   RCurl                               1.98-1.12  2023-03-27 [1] CRAN (R 4.3.1)\n##   readr                               2.1.4      2023-02-10 [1] CRAN (R 4.3.1)\n##   rebook                              1.11.1     2023-05-25 [1] Bioconductor\n##   rematch2                            2.1.2      2020-05-01 [1] CRAN (R 4.3.1)\n##   remotes                             2.4.2.1    2023-07-18 [1] CRAN (R 4.3.1)\n##   renv                                1.0.1      2023-08-10 [1] CRAN (R 4.3.1)\n##   restfulr                            0.0.15     2022-06-16 [1] CRAN (R 4.3.1)\n##   Rhtslib                             2.3.0      2023-04-25 [1] Bioconductor\n##   rjson                               0.2.21     2022-01-09 [1] CRAN (R 4.3.1)\n##   rlang                               1.1.1      2023-04-28 [1] CRAN (R 4.3.1)\n##   rmarkdown                           2.23       2023-07-01 [1] CRAN (R 4.3.1)\n##   roxygen2                            7.2.3      2022-12-08 [1] CRAN (R 4.3.1)\n##   rpart                               4.1.19     2022-10-21 [2] CRAN (R 4.3.1)\n##   rprojroot                           2.0.3      2022-04-02 [1] CRAN (R 4.3.1)\n##   Rsamtools                           2.17.0     2023-04-25 [1] Bioconductor\n##   rsconnect                           1.0.1      2023-07-20 [1] CRAN (R 4.3.1)\n##   RSQLite                             2.3.1      2023-04-03 [1] CRAN (R 4.3.1)\n##   rstudioapi                          0.15.0     2023-07-07 [1] CRAN (R 4.3.1)\n##   rtracklayer                         1.61.0     2023-04-25 [1] Bioconductor\n##   rversions                           2.1.2      2022-08-31 [1] CRAN (R 4.3.1)\n##   S4Arrays                            1.1.5      2023-07-24 [1] Bioconductor\n##   S4Vectors                           0.39.1     2023-05-03 [1] Bioconductor\n##   sass                                0.4.7      2023-07-15 [1] CRAN (R 4.3.1)\n##   scales                              1.2.1      2022-08-20 [1] CRAN (R 4.3.1)\n##   sessioninfo                         1.2.2      2021-12-06 [1] CRAN (R 4.3.1)\n##   shape                               1.4.6      2021-05-19 [1] CRAN (R 4.3.1)\n##   shiny                               1.7.4.1    2023-07-06 [1] CRAN (R 4.3.1)\n##   snow                                0.4-4      2021-10-27 [1] CRAN (R 4.3.1)\n##   SnowballC                           0.7.1      2023-04-25 [1] CRAN (R 4.3.1)\n##   sourcetools                         0.1.7-1    2023-02-01 [1] CRAN (R 4.3.1)\n##   SparseArray                         1.1.11     2023-07-25 [1] Bioconductor\n##   spatial                             7.3-17     2023-07-20 [1] CRAN (R 4.3.1)\n##   splines                             4.3.1      2023-08-10 [2] local\n##   statmod                             1.5.0      2023-01-06 [1] CRAN (R 4.3.1)\n##   stats                             * 4.3.1      2023-08-10 [2] local\n##   stats4                              4.3.1      2023-08-10 [2] local\n##   strawr                              0.0.91     2023-03-29 [1] CRAN (R 4.3.1)\n##   stringdist                          0.9.10     2022-11-07 [1] CRAN (R 4.3.1)\n##   stringi                             1.7.12     2023-01-11 [1] CRAN (R 4.3.1)\n##   stringr                             1.5.0      2022-12-02 [1] CRAN (R 4.3.1)\n##   SummarizedExperiment                1.31.1     2023-05-01 [1] Bioconductor\n##   survival                            3.5-5      2023-03-12 [2] CRAN (R 4.3.1)\n##   sys                                 3.4.2      2023-05-23 [1] CRAN (R 4.3.1)\n##   systemfonts                         1.0.4      2022-02-11 [1] CRAN (R 4.3.1)\n##   tcltk                               4.3.1      2023-08-10 [2] local\n##   testthat                            3.1.10     2023-07-06 [1] CRAN (R 4.3.1)\n##   textshaping                         0.3.6      2021-10-13 [1] CRAN (R 4.3.1)\n##   tibble                              3.2.1      2023-03-20 [1] CRAN (R 4.3.1)\n##   tidybulk                            1.13.0     2023-04-25 [1] Bioconductor\n##   tidyr                               1.3.0      2023-01-24 [1] CRAN (R 4.3.1)\n##   tidyselect                          1.2.0      2022-10-10 [1] CRAN (R 4.3.1)\n##   tidySummarizedExperiment            1.11.1     2023-06-21 [1] Bioconductor\n##   tidytext                            0.4.1      2023-01-07 [1] CRAN (R 4.3.1)\n##   tinytex                             0.46       2023-08-09 [1] CRAN (R 4.3.1)\n##   tokenizers                          0.3.0      2022-12-22 [1] CRAN (R 4.3.1)\n##   tools                               4.3.1      2023-08-10 [2] local\n##   toOrdinal                           1.3-0.0    2022-02-24 [1] CRAN (R 4.3.1)\n##   ttservice                           0.3.6      2023-06-20 [1] CRAN (R 4.3.1)\n##   TxDb.Hsapiens.UCSC.hg19.knownGene   3.2.2      2023-08-12 [1] Bioconductor\n##   tximeta                             1.19.3     2023-08-01 [1] Bioconductor\n##   tximport                            1.29.0     2023-04-25 [1] Bioconductor\n##   tzdb                                0.4.0      2023-05-12 [1] CRAN (R 4.3.1)\n##   urlchecker                          1.0.1      2021-11-30 [1] CRAN (R 4.3.1)\n##   usethis                             2.2.2      2023-07-06 [1] CRAN (R 4.3.1)\n##   utf8                                1.2.3      2023-01-31 [1] CRAN (R 4.3.1)\n##   utils                             * 4.3.1      2023-08-10 [2] local\n##   vctrs                               0.6.3      2023-06-14 [1] CRAN (R 4.3.1)\n##   viridisLite                         0.4.2      2023-05-02 [1] CRAN (R 4.3.1)\n##   vroom                               1.6.3      2023-04-28 [1] CRAN (R 4.3.1)\n##   waldo                               0.5.1      2023-05-08 [1] CRAN (R 4.3.1)\n##   whisker                             0.4.1      2022-12-05 [1] CRAN (R 4.3.1)\n##   withr                               2.5.0      2022-03-03 [1] CRAN (R 4.3.1)\n##   xfun                                0.40       2023-08-09 [1] CRAN (R 4.3.1)\n##   XML                                 3.99-0.14  2023-03-19 [1] CRAN (R 4.3.1)\n##   xml2                                1.3.5      2023-07-06 [1] CRAN (R 4.3.1)\n##   xopen                               1.0.0      2018-09-17 [1] CRAN (R 4.3.1)\n##   xtable                              1.8-4      2019-04-21 [1] CRAN (R 4.3.1)\n##   XVector                             0.41.1     2023-05-03 [1] Bioconductor\n##   yaml                                2.3.7      2023-01-23 [1] CRAN (R 4.3.1)\n##   yesno                               0.1.2      2020-07-10 [1] CRAN (R 4.3.1)\n##   yulab.utils                         0.0.7      2023-08-09 [1] CRAN (R 4.3.1)\n##   zip                                 2.3.0      2023-04-17 [1] CRAN (R 4.3.1)\n##   zlibbioc                            1.47.0     2023-04-25 [1] Bioconductor\n##  \n##   [1] /usr/local/lib/R/site-library\n##   [2] /usr/local/lib/R/library\n##  \n##  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\n\n\n\n\n\n Back to top"
  },
  {
    "objectID": "pages/join-is-an-overlap.html",
    "href": "pages/join-is-an-overlap.html",
    "title": "\n1¬† Join is an overlap\n",
    "section": "",
    "text": "Objectives\n\n\n\n\nLearn that a join operation implies finding overlapping data in two tables, according to some particular criterion.\n\n\n\nWe start with a quick example explaining why we use functions called join. Later we will extend from simple tables to examples making use of genomic ranges.\n\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(randomNames)\n\nLet‚Äôs set up a simulation where we have 17 classmates (not counting ourselves) in a school of 118. Suppose every member of the class has 12 friends outside of class.\nWe want to find out, for each classmate, how many friends we have in common and also, of our shared friends, what is a typical birthday. Let‚Äôs define typical as the median birthday of our shared friends.\n\nm &lt;- 17 # size of class\nn &lt;- 100 # size of others in school\nnf &lt;- 12 # number of friends outside class\nset.seed(5)\npeople &lt;- randomNames(\n    m + n,\n    name.order=\"first.last\",\n    name.sep=\" \"\n)\n\nWe define the population of potential friends (those outside the class) as pop, and our 12 friends are in friends. Finally, we define the people that are in our class as class_people.\n\npop &lt;- data.frame(\n    person=people[-(1:m)],\n    birthday=sample(31, n, TRUE)\n)\nfriends &lt;- data.frame(friend=sample(people, nf))\nclass_people &lt;- people[1:m]\n\nThe following sets up a data.frame, where each row gives, for a given classmate, their friends, and the friends‚Äô birthdays.\n\nloop &lt;- rep(1:m, each=nf)\nidx &lt;- as.vector(replicate(m, sample(n, nf)))\nclass &lt;- data.frame(\n    classmate=class_people[loop],\n    friend=pop$person[idx],\n    birthday=pop$birthday[idx]\n)\n\nSort this by classmate alphabetically, and make classmate into a factor. This last step is important, as it will help us to keep track of the classmates for whom we share no friends outside of class.\n\nclass &lt;- class |&gt; \n  arrange(classmate) |&gt; \n  mutate(classmate=factor(classmate))\n\nWe perform an inner_join by \"friend\". This just means we look for classmates where we have overlapping friends, and we drop the rows where we don‚Äôt share any friends. ‚ÄúInner‚Äù refers to the fact that we are keeping the overlap in the inside of two intersecting circles. Note that the join operation brings along the metadata (extra data) about the friends‚Äô birthdays.\n\nshared_friends &lt;- friends |&gt; \n  inner_join(class, by=\"friend\") |&gt; \n  arrange(classmate, friend) |&gt; \n  relocate(classmate) # classmate to 1st column\nshared_friends\n##                 classmate             friend birthday\n##  1          Brandon Jones Christopher Rivera       13\n##  2          Brandon Jones       Jose Jimenez       26\n##  3          Brandon Jones    Maria Hernandez       15\n##  4          Brandon Jones         Tuli Hoang        7\n##  5     Christopher Herron         Tuli Hoang        7\n##  6     Christopher Herron  William Steinbach       15\n##  7         Haley Polhamus   Cellene Millhone       23\n##  8         Haley Polhamus  William Steinbach       15\n##  9  Juan Villegas Cabrera     Alyssa Kinanee       30\n##  10 Juan Villegas Cabrera       Malik Gammon        5\n##  11 Juan Villegas Cabrera     Tajhae Bohanna       31\n##  12     Maisara el-Arshad     Kaylyn Judkins        2\n##  13     Maisara el-Arshad    Maria Hernandez       15\n##  14     Maisara el-Arshad     Tajhae Bohanna       31\n##  15        Michael Mcgill Christopher Rivera       13\n##  16        Michael Mcgill    Maria Hernandez       15\n##  17        Noah Pettinger     Kaylyn Judkins        2\n##  18        Noah Pettinger     Tajhae Bohanna       31\n##  19         Orion Villani       Malik Gammon        5\n##  20         Shane Ranaldi     Alyssa Kinanee       30\n##  21         Shane Ranaldi  William Steinbach       15\n##  22   Stephanie Hernandez Asmaa el-Abdelnour       29\n##  23   Zachary Roe-Huffman    Maria Hernandez       15\n\nLastly, we perform some summarization: compute the number of friends in common with n() and the median birthday of shared friends. The complete call at the end fills in 0 for those classmates for whom we share no friends (here, the use of factor earlier becomes relevant). We can choose which columns to fill in, and what value to add.\n\nshared_friends |&gt; \n  group_by(classmate) |&gt; \n  summarize(in_common=n(), median_bday=median(birthday)) |&gt; \n  complete(classmate, fill=list(in_common=0,median_bday=-1))\n##  # A tibble: 17 √ó 3\n##    classmate             in_common median_bday\n##    &lt;fct&gt;                     &lt;int&gt;       &lt;dbl&gt;\n##  1 Aaliyah Minter                0          -1\n##  2 Brandon Jones                 4          14\n##  3 Christopher Herron            2          11\n##  4 Collin Leon                   0          -1\n##  5 Haley Polhamus                2          19\n##  6 Juan Villegas Cabrera         3          30\n##  # ‚Ñπ 11 more rows\n\nSession info\n\n\n\n\n\n\nClick to expand üëá\n\n\n\n\n\n\nsessioninfo::session_info(\n    installed.packages()[,\"Package\"], \n    include_base = TRUE\n)\n##  ‚îÄ Session info ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n##   setting  value\n##   version  R version 4.3.1 (2023-06-16)\n##   os       Ubuntu 22.04.2 LTS\n##   system   x86_64, linux-gnu\n##   ui       X11\n##   language (EN)\n##   collate  en_US.UTF-8\n##   ctype    en_US.UTF-8\n##   tz       Etc/UTC\n##   date     2023-08-12\n##   pandoc   3.1.1 @ /usr/local/bin/ (via rmarkdown)\n##  \n##  ‚îÄ Packages ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n##   package                           * version    date (UTC) lib source\n##   abind                               1.4-5      2016-07-21 [1] CRAN (R 4.3.1)\n##   AnnotationDbi                       1.63.2     2023-07-02 [1] Bioconductor\n##   AnnotationFilter                    1.25.0     2023-04-25 [1] Bioconductor\n##   AnnotationHub                       3.9.1      2023-05-01 [1] Bioconductor\n##   askpass                             1.1        2019-01-13 [1] CRAN (R 4.3.1)\n##   available                           1.1.0      2022-07-10 [1] CRAN (R 4.3.1)\n##   base                              * 4.3.1      2023-08-10 [2] local\n##   base64enc                           0.1-3      2015-07-28 [1] CRAN (R 4.3.1)\n##   BH                                  1.81.0-1   2023-01-22 [1] CRAN (R 4.3.1)\n##   Biobase                             2.61.0     2023-04-25 [1] Bioconductor\n##   BiocBook                            0.99.0     2023-08-12 [1] Github (js2264/BiocBook@1ef3442)\n##   BiocBook.GRanges                    0.99.0     2023-08-12 [1] local\n##   BiocFileCache                       2.9.1      2023-07-12 [1] Bioconductor\n##   BiocGenerics                        0.47.0     2023-04-25 [1] Bioconductor\n##   BiocIO                              1.11.0     2023-04-25 [1] Bioconductor\n##   BiocManager                         1.30.22    2023-08-08 [1] CRAN (R 4.3.1)\n##   BiocParallel                        1.35.3     2023-07-07 [1] Bioconductor\n##   BiocStyle                           2.29.1     2023-07-19 [1] Bioconductor\n##   BiocVersion                         3.18.0     2023-04-25 [1] Bioconductor\n##   biomaRt                             2.57.1     2023-06-09 [1] Bioconductor\n##   Biostrings                          2.69.2     2023-07-02 [1] Bioconductor\n##   bit                                 4.0.5      2022-11-15 [1] CRAN (R 4.3.1)\n##   bit64                               4.0.5      2020-08-30 [1] CRAN (R 4.3.1)\n##   bitops                              1.0-7      2021-04-24 [1] CRAN (R 4.3.1)\n##   blob                                1.2.4      2023-03-17 [1] CRAN (R 4.3.1)\n##   bookdown                            0.35       2023-08-09 [1] CRAN (R 4.3.1)\n##   boot                                1.3-28.1   2022-11-22 [2] CRAN (R 4.3.1)\n##   bootstrap                           2019.6     2019-06-17 [1] CRAN (R 4.3.1)\n##   brew                                1.0-8      2022-09-29 [1] CRAN (R 4.3.1)\n##   brio                                1.1.3      2021-11-30 [1] CRAN (R 4.3.1)\n##   bslib                               0.5.1      2023-08-11 [1] CRAN (R 4.3.1)\n##   cachem                              1.0.8      2023-05-01 [1] CRAN (R 4.3.1)\n##   callr                               3.7.3      2022-11-02 [1] CRAN (R 4.3.1)\n##   class                               7.3-22     2023-05-03 [2] CRAN (R 4.3.1)\n##   cli                                 3.6.1      2023-03-23 [1] CRAN (R 4.3.1)\n##   clipr                               0.8.0      2022-02-22 [1] CRAN (R 4.3.1)\n##   clisymbols                          1.2.0      2017-05-21 [1] CRAN (R 4.3.1)\n##   cluster                             2.1.4      2022-08-22 [2] CRAN (R 4.3.1)\n##   CodeDepends                         0.6.5      2018-07-17 [1] CRAN (R 4.3.1)\n##   codetools                           0.2-19     2023-02-01 [2] CRAN (R 4.3.1)\n##   colorspace                          2.1-0      2023-01-23 [1] CRAN (R 4.3.1)\n##   commonmark                          1.9.0      2023-03-17 [1] CRAN (R 4.3.1)\n##   compiler                            4.3.1      2023-08-10 [2] local\n##   cpp11                               0.4.6      2023-08-10 [1] CRAN (R 4.3.1)\n##   crayon                              1.5.2      2022-09-29 [1] CRAN (R 4.3.1)\n##   credentials                         1.3.2      2021-11-29 [1] CRAN (R 4.3.1)\n##   crosstalk                           1.2.0      2021-11-04 [1] CRAN (R 4.3.1)\n##   curl                                5.0.1      2023-06-07 [1] CRAN (R 4.3.1)\n##   data.table                          1.14.8     2023-02-17 [1] CRAN (R 4.3.1)\n##   datasets                          * 4.3.1      2023-08-10 [2] local\n##   DBI                                 1.1.3      2022-06-18 [1] CRAN (R 4.3.1)\n##   dbplyr                              2.3.3      2023-07-07 [1] CRAN (R 4.3.1)\n##   DelayedArray                        0.27.10    2023-07-28 [1] Bioconductor\n##   desc                                1.4.2      2022-09-08 [1] CRAN (R 4.3.1)\n##   DESeq2                              1.41.6     2023-07-24 [1] Bioconductor\n##   devtools                            2.4.5      2022-10-11 [1] CRAN (R 4.3.1)\n##   diffobj                             0.3.5      2021-10-05 [1] CRAN (R 4.3.1)\n##   digest                              0.6.33     2023-07-07 [1] CRAN (R 4.3.1)\n##   dir.expiry                          1.9.0      2023-04-25 [1] Bioconductor\n##   docopt                              0.7.1      2020-06-24 [1] CRAN (R 4.3.1)\n##   downlit                             0.4.3      2023-06-29 [1] CRAN (R 4.3.1)\n##   dplyr                             * 1.1.2      2023-04-20 [1] CRAN (R 4.3.1)\n##   DT                                  0.28       2023-05-18 [1] CRAN (R 4.3.1)\n##   edgeR                               3.43.8     2023-08-02 [1] Bioconductor\n##   ellipsis                            0.3.2      2021-04-29 [1] CRAN (R 4.3.1)\n##   ensembldb                           2.25.0     2023-04-25 [1] Bioconductor\n##   evaluate                            0.21       2023-05-05 [1] CRAN (R 4.3.1)\n##   fansi                               1.0.4      2023-01-22 [1] CRAN (R 4.3.1)\n##   farver                              2.1.1      2022-07-06 [1] CRAN (R 4.3.1)\n##   fastmap                             1.1.1      2023-02-24 [1] CRAN (R 4.3.1)\n##   filelock                            1.0.2      2018-10-05 [1] CRAN (R 4.3.1)\n##   fission                             1.21.0     2023-04-27 [1] Bioconductor\n##   fontawesome                         0.5.1      2023-04-18 [1] CRAN (R 4.3.1)\n##   foreach                             1.5.2      2022-02-02 [1] CRAN (R 4.3.1)\n##   foreign                             0.8-84     2022-12-06 [2] CRAN (R 4.3.1)\n##   formatR                             1.14       2023-01-17 [1] CRAN (R 4.3.1)\n##   fs                                  1.6.3      2023-07-20 [1] CRAN (R 4.3.1)\n##   futile.logger                       1.4.3      2016-07-10 [1] CRAN (R 4.3.1)\n##   futile.options                      1.0.1      2018-04-20 [1] CRAN (R 4.3.1)\n##   generics                            0.1.3      2022-07-05 [1] CRAN (R 4.3.1)\n##   GenomeInfoDb                        1.37.2     2023-06-21 [1] Bioconductor\n##   GenomeInfoDbData                    1.2.10     2023-08-12 [1] Bioconductor\n##   GenomicAlignments                   1.37.0     2023-04-25 [1] Bioconductor\n##   GenomicFeatures                     1.53.1     2023-06-22 [1] Bioconductor\n##   GenomicRanges                       1.53.1     2023-05-04 [1] Bioconductor\n##   gert                                1.9.3      2023-08-07 [1] CRAN (R 4.3.1)\n##   ggplot2                             3.4.2      2023-04-03 [1] CRAN (R 4.3.1)\n##   ggplotify                           0.1.2      2023-08-09 [1] CRAN (R 4.3.1)\n##   ggrepel                             0.9.3      2023-02-03 [1] CRAN (R 4.3.1)\n##   ggridges                            0.5.4      2022-09-26 [1] CRAN (R 4.3.1)\n##   gh                                  1.4.0      2023-02-22 [1] CRAN (R 4.3.1)\n##   gitcreds                            0.1.2      2022-09-08 [1] CRAN (R 4.3.1)\n##   glmnet                              4.1-7      2023-03-23 [1] CRAN (R 4.3.1)\n##   glue                                1.6.2      2022-02-24 [1] CRAN (R 4.3.1)\n##   graph                               1.79.0     2023-04-25 [1] Bioconductor\n##   graphics                          * 4.3.1      2023-08-10 [2] local\n##   grDevices                         * 4.3.1      2023-08-10 [2] local\n##   grid                                4.3.1      2023-08-10 [2] local\n##   gridGraphics                        0.5-1      2020-12-13 [1] CRAN (R 4.3.1)\n##   gtable                              0.3.3      2023-03-21 [1] CRAN (R 4.3.1)\n##   highr                               0.10       2022-12-22 [1] CRAN (R 4.3.1)\n##   hms                                 1.1.3      2023-03-21 [1] CRAN (R 4.3.1)\n##   htmltools                           0.5.6      2023-08-10 [1] CRAN (R 4.3.1)\n##   htmlwidgets                         1.6.2      2023-03-17 [1] CRAN (R 4.3.1)\n##   httpuv                              1.6.11     2023-05-11 [1] CRAN (R 4.3.1)\n##   httr                                1.4.6      2023-05-08 [1] CRAN (R 4.3.1)\n##   httr2                               0.2.3      2023-05-08 [1] CRAN (R 4.3.1)\n##   ini                                 0.3.1      2018-05-20 [1] CRAN (R 4.3.1)\n##   InteractionSet                      1.29.1     2023-06-14 [1] Bioconductor\n##   interactiveDisplayBase              1.39.0     2023-04-25 [1] Bioconductor\n##   IRanges                             2.35.2     2023-06-22 [1] Bioconductor\n##   isoband                             0.2.7      2022-12-20 [1] CRAN (R 4.3.1)\n##   iterators                           1.0.14     2022-02-05 [1] CRAN (R 4.3.1)\n##   janeaustenr                         1.0.0      2022-08-26 [1] CRAN (R 4.3.1)\n##   jquerylib                           0.1.4      2021-04-26 [1] CRAN (R 4.3.1)\n##   jsonlite                            1.8.7      2023-06-29 [1] CRAN (R 4.3.1)\n##   KEGGREST                            1.41.0     2023-04-25 [1] Bioconductor\n##   KernSmooth                          2.23-22    2023-07-10 [1] CRAN (R 4.3.1)\n##   knitr                               1.43       2023-05-25 [1] CRAN (R 4.3.1)\n##   labeling                            0.4.2      2020-10-20 [1] CRAN (R 4.3.1)\n##   lambda.r                            1.2.4      2019-09-18 [1] CRAN (R 4.3.1)\n##   later                               1.3.1      2023-05-02 [1] CRAN (R 4.3.1)\n##   lattice                             0.21-8     2023-04-05 [2] CRAN (R 4.3.1)\n##   lazyeval                            0.2.2      2019-03-15 [1] CRAN (R 4.3.1)\n##   lifecycle                           1.0.3      2022-10-07 [1] CRAN (R 4.3.1)\n##   limma                               3.57.7     2023-08-02 [1] Bioconductor\n##   littler                             0.3.18     2023-03-26 [1] CRAN (R 4.3.1)\n##   locfit                              1.5-9.8    2023-06-11 [1] CRAN (R 4.3.1)\n##   macrophage                          1.17.0     2023-04-27 [1] Bioconductor\n##   magrittr                            2.0.3      2022-03-30 [1] CRAN (R 4.3.1)\n##   MASS                                7.3-60     2023-05-04 [2] CRAN (R 4.3.1)\n##   Matrix                              1.6-0      2023-07-08 [1] CRAN (R 4.3.1)\n##   MatrixGenerics                      1.13.1     2023-07-25 [1] Bioconductor\n##   matrixStats                         1.0.0      2023-06-02 [1] CRAN (R 4.3.1)\n##   memoise                             2.0.1      2021-11-26 [1] CRAN (R 4.3.1)\n##   methods                           * 4.3.1      2023-08-10 [2] local\n##   mgcv                                1.9-0      2023-07-11 [1] CRAN (R 4.3.1)\n##   mime                                0.12       2021-09-28 [1] CRAN (R 4.3.1)\n##   miniUI                              0.1.1.1    2018-05-18 [1] CRAN (R 4.3.1)\n##   munsell                             0.5.0      2018-06-12 [1] CRAN (R 4.3.1)\n##   nlme                                3.1-163    2023-08-09 [1] CRAN (R 4.3.1)\n##   nnet                                7.3-19     2023-05-03 [2] CRAN (R 4.3.1)\n##   nullranges                          1.7.9      2023-08-06 [1] Bioconductor\n##   oct4                                1.17.0     2023-04-27 [1] Bioconductor\n##   openssl                             2.1.0      2023-07-15 [1] CRAN (R 4.3.1)\n##   org.Hs.eg.db                        3.17.0     2023-08-12 [1] Bioconductor\n##   org.Mm.eg.db                        3.17.0     2023-08-12 [1] Bioconductor\n##   packrat                             0.9.1      2023-02-27 [1] CRAN (R 4.3.1)\n##   pak                                 0.5.1.9000 2023-08-02 [1] local\n##   parallel                            4.3.1      2023-08-10 [2] local\n##   pillar                              1.9.0      2023-03-22 [1] CRAN (R 4.3.1)\n##   pkgbuild                            1.4.2      2023-06-26 [1] CRAN (R 4.3.1)\n##   pkgconfig                           2.0.3      2019-09-22 [1] CRAN (R 4.3.1)\n##   pkgdown                             2.0.7      2022-12-14 [1] CRAN (R 4.3.1)\n##   pkgload                             1.3.2.1    2023-07-08 [1] CRAN (R 4.3.1)\n##   plogr                               0.2.0      2018-03-25 [1] CRAN (R 4.3.1)\n##   plotgardener                        1.7.7      2023-08-04 [1] Bioconductor\n##   plotly                              4.10.2     2023-06-03 [1] CRAN (R 4.3.1)\n##   plyranges                           1.21.0     2023-04-25 [1] Bioconductor\n##   png                                 0.1-8      2022-11-29 [1] CRAN (R 4.3.1)\n##   praise                              1.0.0      2015-08-11 [1] CRAN (R 4.3.1)\n##   preprocessCore                      1.63.1     2023-05-02 [1] Bioconductor\n##   prettyunits                         1.1.1      2020-01-24 [1] CRAN (R 4.3.1)\n##   processx                            3.8.2      2023-06-30 [1] CRAN (R 4.3.1)\n##   profvis                             0.3.8      2023-05-02 [1] CRAN (R 4.3.1)\n##   progress                            1.2.2      2019-05-16 [1] CRAN (R 4.3.1)\n##   promises                            1.2.1      2023-08-10 [1] CRAN (R 4.3.1)\n##   ProtGenerics                        1.33.1     2023-06-16 [1] Bioconductor\n##   ps                                  1.7.5      2023-04-18 [1] CRAN (R 4.3.1)\n##   purrr                               1.0.2      2023-08-10 [1] CRAN (R 4.3.1)\n##   quarto                              1.2        2022-07-06 [1] CRAN (R 4.3.1)\n##   R6                                  2.5.1      2021-08-19 [1] CRAN (R 4.3.1)\n##   ragg                                1.2.5      2023-01-12 [1] CRAN (R 4.3.1)\n##   randomNames                       * 1.5-0.0    2021-04-22 [1] CRAN (R 4.3.1)\n##   rappdirs                            0.3.3      2021-01-31 [1] CRAN (R 4.3.1)\n##   rcmdcheck                           1.4.0      2021-09-27 [1] CRAN (R 4.3.1)\n##   RColorBrewer                        1.1-3      2022-04-03 [1] CRAN (R 4.3.1)\n##   Rcpp                                1.0.11     2023-07-06 [1] CRAN (R 4.3.1)\n##   RcppArmadillo                       0.12.6.1.0 2023-08-10 [1] CRAN (R 4.3.1)\n##   RcppEigen                           0.3.3.9.3  2022-11-05 [1] CRAN (R 4.3.1)\n##   RCurl                               1.98-1.12  2023-03-27 [1] CRAN (R 4.3.1)\n##   readr                               2.1.4      2023-02-10 [1] CRAN (R 4.3.1)\n##   rebook                              1.11.1     2023-05-25 [1] Bioconductor\n##   rematch2                            2.1.2      2020-05-01 [1] CRAN (R 4.3.1)\n##   remotes                             2.4.2.1    2023-07-18 [1] CRAN (R 4.3.1)\n##   renv                                1.0.1      2023-08-10 [1] CRAN (R 4.3.1)\n##   restfulr                            0.0.15     2022-06-16 [1] CRAN (R 4.3.1)\n##   Rhtslib                             2.3.0      2023-04-25 [1] Bioconductor\n##   rjson                               0.2.21     2022-01-09 [1] CRAN (R 4.3.1)\n##   rlang                               1.1.1      2023-04-28 [1] CRAN (R 4.3.1)\n##   rmarkdown                           2.23       2023-07-01 [1] CRAN (R 4.3.1)\n##   roxygen2                            7.2.3      2022-12-08 [1] CRAN (R 4.3.1)\n##   rpart                               4.1.19     2022-10-21 [2] CRAN (R 4.3.1)\n##   rprojroot                           2.0.3      2022-04-02 [1] CRAN (R 4.3.1)\n##   Rsamtools                           2.17.0     2023-04-25 [1] Bioconductor\n##   rsconnect                           1.0.1      2023-07-20 [1] CRAN (R 4.3.1)\n##   RSQLite                             2.3.1      2023-04-03 [1] CRAN (R 4.3.1)\n##   rstudioapi                          0.15.0     2023-07-07 [1] CRAN (R 4.3.1)\n##   rtracklayer                         1.61.0     2023-04-25 [1] Bioconductor\n##   rversions                           2.1.2      2022-08-31 [1] CRAN (R 4.3.1)\n##   S4Arrays                            1.1.5      2023-07-24 [1] Bioconductor\n##   S4Vectors                           0.39.1     2023-05-03 [1] Bioconductor\n##   sass                                0.4.7      2023-07-15 [1] CRAN (R 4.3.1)\n##   scales                              1.2.1      2022-08-20 [1] CRAN (R 4.3.1)\n##   sessioninfo                         1.2.2      2021-12-06 [1] CRAN (R 4.3.1)\n##   shape                               1.4.6      2021-05-19 [1] CRAN (R 4.3.1)\n##   shiny                               1.7.4.1    2023-07-06 [1] CRAN (R 4.3.1)\n##   snow                                0.4-4      2021-10-27 [1] CRAN (R 4.3.1)\n##   SnowballC                           0.7.1      2023-04-25 [1] CRAN (R 4.3.1)\n##   sourcetools                         0.1.7-1    2023-02-01 [1] CRAN (R 4.3.1)\n##   SparseArray                         1.1.11     2023-07-25 [1] Bioconductor\n##   spatial                             7.3-17     2023-07-20 [1] CRAN (R 4.3.1)\n##   splines                             4.3.1      2023-08-10 [2] local\n##   statmod                             1.5.0      2023-01-06 [1] CRAN (R 4.3.1)\n##   stats                             * 4.3.1      2023-08-10 [2] local\n##   stats4                              4.3.1      2023-08-10 [2] local\n##   strawr                              0.0.91     2023-03-29 [1] CRAN (R 4.3.1)\n##   stringdist                          0.9.10     2022-11-07 [1] CRAN (R 4.3.1)\n##   stringi                             1.7.12     2023-01-11 [1] CRAN (R 4.3.1)\n##   stringr                             1.5.0      2022-12-02 [1] CRAN (R 4.3.1)\n##   SummarizedExperiment                1.31.1     2023-05-01 [1] Bioconductor\n##   survival                            3.5-5      2023-03-12 [2] CRAN (R 4.3.1)\n##   sys                                 3.4.2      2023-05-23 [1] CRAN (R 4.3.1)\n##   systemfonts                         1.0.4      2022-02-11 [1] CRAN (R 4.3.1)\n##   tcltk                               4.3.1      2023-08-10 [2] local\n##   testthat                            3.1.10     2023-07-06 [1] CRAN (R 4.3.1)\n##   textshaping                         0.3.6      2021-10-13 [1] CRAN (R 4.3.1)\n##   tibble                              3.2.1      2023-03-20 [1] CRAN (R 4.3.1)\n##   tidybulk                            1.13.0     2023-04-25 [1] Bioconductor\n##   tidyr                             * 1.3.0      2023-01-24 [1] CRAN (R 4.3.1)\n##   tidyselect                          1.2.0      2022-10-10 [1] CRAN (R 4.3.1)\n##   tidySummarizedExperiment            1.11.1     2023-06-21 [1] Bioconductor\n##   tidytext                            0.4.1      2023-01-07 [1] CRAN (R 4.3.1)\n##   tinytex                             0.46       2023-08-09 [1] CRAN (R 4.3.1)\n##   tokenizers                          0.3.0      2022-12-22 [1] CRAN (R 4.3.1)\n##   tools                               4.3.1      2023-08-10 [2] local\n##   toOrdinal                           1.3-0.0    2022-02-24 [1] CRAN (R 4.3.1)\n##   ttservice                           0.3.6      2023-06-20 [1] CRAN (R 4.3.1)\n##   TxDb.Hsapiens.UCSC.hg19.knownGene   3.2.2      2023-08-12 [1] Bioconductor\n##   tximeta                             1.19.3     2023-08-01 [1] Bioconductor\n##   tximport                            1.29.0     2023-04-25 [1] Bioconductor\n##   tzdb                                0.4.0      2023-05-12 [1] CRAN (R 4.3.1)\n##   urlchecker                          1.0.1      2021-11-30 [1] CRAN (R 4.3.1)\n##   usethis                             2.2.2      2023-07-06 [1] CRAN (R 4.3.1)\n##   utf8                                1.2.3      2023-01-31 [1] CRAN (R 4.3.1)\n##   utils                             * 4.3.1      2023-08-10 [2] local\n##   vctrs                               0.6.3      2023-06-14 [1] CRAN (R 4.3.1)\n##   viridisLite                         0.4.2      2023-05-02 [1] CRAN (R 4.3.1)\n##   vroom                               1.6.3      2023-04-28 [1] CRAN (R 4.3.1)\n##   waldo                               0.5.1      2023-05-08 [1] CRAN (R 4.3.1)\n##   whisker                             0.4.1      2022-12-05 [1] CRAN (R 4.3.1)\n##   withr                               2.5.0      2022-03-03 [1] CRAN (R 4.3.1)\n##   xfun                                0.40       2023-08-09 [1] CRAN (R 4.3.1)\n##   XML                                 3.99-0.14  2023-03-19 [1] CRAN (R 4.3.1)\n##   xml2                                1.3.5      2023-07-06 [1] CRAN (R 4.3.1)\n##   xopen                               1.0.0      2018-09-17 [1] CRAN (R 4.3.1)\n##   xtable                              1.8-4      2019-04-21 [1] CRAN (R 4.3.1)\n##   XVector                             0.41.1     2023-05-03 [1] Bioconductor\n##   yaml                                2.3.7      2023-01-23 [1] CRAN (R 4.3.1)\n##   yesno                               0.1.2      2020-07-10 [1] CRAN (R 4.3.1)\n##   yulab.utils                         0.0.7      2023-08-09 [1] CRAN (R 4.3.1)\n##   zip                                 2.3.0      2023-04-17 [1] CRAN (R 4.3.1)\n##   zlibbioc                            1.47.0     2023-04-25 [1] Bioconductor\n##  \n##   [1] /usr/local/lib/R/site-library\n##   [2] /usr/local/lib/R/library\n##  \n##  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\n\n\n\n\n\n Back to top"
  },
  {
    "objectID": "pages/compute-overlaps.html",
    "href": "pages/compute-overlaps.html",
    "title": "\n2¬† Compute overlaps\n",
    "section": "",
    "text": "Objectives\n\n\n\n\nCompute overlaps and summary statistics between two sets of genomic ranges\n\n\n\nSuppose we want to compute the mean genomic extent (distance from left-most to right-most basepair) of genes overlapping a set of query ranges.\nWe move on from the ‚Äúclassroom example‚Äù by seeing how we compute overlaps when the features are in genomic space. We will use GRanges in the Bioconductor package GenomicRanges (Lawrence et al. 2013) to represent the features and plyranges (Lee, Cook, and Lawrence 2019) to compute the overlaps, similarly to how we used dplyr to compute the overlaps in the previous analysis. So data.frame is to dplyr as GRanges is to plyranges.\n\nLawrence, Michael, Wolfgang Huber, Herv√© Pag√®s, Patrick Aboyoun, Marc Carlson, Robert Gentleman, Martin T Morgan, and Vincent J Carey. 2013. ‚ÄúSoftware for Computing and Annotating Genomic Ranges.‚Äù PLoS Comput. Biol. 9 (8): e1003118.\n\nLee, Stuart, Dianne Cook, and Michael Lawrence. 2019. ‚ÄúPlyranges: A Grammar of Genomic Data Transformation.‚Äù Genome Biol. 20 (1): 4.\n\nlibrary(plyranges)\n\nNote the structure of the GRanges object. We can create a GRanges from a data.frame by specifying two of: start, end, or width.\n\ndf &lt;- data.frame(\n    seqnames=\"chr1\",\n    start=1 + c(34e6,36e6,36.6e6),\n    width=c(2e5,2e5,1e5),\n    strand=c(\"+\",\"-\",\"-\"),\n    range_id=factor(c(\"foo\",\"bar\",\"boo\")))\nr &lt;- as_granges(df)\nr\n##  GRanges object with 3 ranges and 1 metadata column:\n##        seqnames            ranges strand | range_id\n##           &lt;Rle&gt;         &lt;IRanges&gt;  &lt;Rle&gt; | &lt;factor&gt;\n##    [1]     chr1 34000001-34200000      + |      foo\n##    [2]     chr1 36000001-36200000      - |      bar\n##    [3]     chr1 36600001-36700000      - |      boo\n##    -------\n##    seqinfo: 1 sequence from an unspecified genome; no seqlengths\n\nIn case you haven‚Äôt seen this before, GRanges objects have specific functions to pull out information. See ?GRanges for details.\n\nlength(r)\n##  [1] 3\nseqnames(r)\n##  factor-Rle of length 3 with 1 run\n##    Lengths:    3\n##    Values : chr1\n##  Levels(1): chr1\nstrand(r)\n##  factor-Rle of length 3 with 2 runs\n##    Lengths: 1 2\n##    Values : + -\n##  Levels(3): + - *\n\nLet‚Äôs use plyranges to find the genes that overlap a region of interest.\nTypically, it is prefered to use Ensembl or GENCODE gene annotation, the latter of which can by obtained from AnnotationHub. Ensembl gene annotation can be easily manipulated with the ensembldb package (Rainer, Gatto, and Weichenberger 2019). Provided is some example code in an unevaluated code chunk:\n\nRainer, Johannes, Laurent Gatto, and Christian X Weichenberger. 2019. ‚Äúensembldb: an R package to create and use Ensembl-based annotation resources.‚Äù Bioinformatics 35 (17): 3151‚Äì53. https://doi.org/10.1093/bioinformatics/btz031.\n\nlibrary(ensembldb)\nedb &lt;- ... # obtain from AnnotationHub or from GTF file\ng &lt;- genes(edb)\n\nHere, we will work with a static TxDb that is distributed as an annotation package in Bioconductor. We use this TxDb because it is an older genome release (hg19) that matches some ranges we will work with later, but generally it is recommended to use a recent (and versioned) Ensembl or GENCODE gene annotation.\n\nlibrary(TxDb.Hsapiens.UCSC.hg19.knownGene)\n\nThe same function can be used to extract the gene ranges:\n\ng &lt;- genes(TxDb.Hsapiens.UCSC.hg19.knownGene)\n##    403 genes were dropped because they have exons located on both\n##    strands of the same reference sequence or on more than one reference\n##    sequence, so cannot be represented by a single genomic range.\n##    Use 'single.strand.genes.only=FALSE' to get all the genes in a\n##    GRangesList object, or use suppressMessages() to suppress this\n##    message.\ng &lt;- keepStandardChromosomes(g, pruning.mode=\"coarse\")\ng\n##  GRanges object with 23033 ranges and 1 metadata column:\n##          seqnames              ranges strand |     gene_id\n##             &lt;Rle&gt;           &lt;IRanges&gt;  &lt;Rle&gt; | &lt;character&gt;\n##        1    chr19   58858172-58874214      - |           1\n##       10     chr8   18248755-18258723      + |          10\n##      100    chr20   43248163-43280376      - |         100\n##     1000    chr18   25530930-25757445      - |        1000\n##    10000     chr1 243651535-244006886      - |       10000\n##      ...      ...                 ...    ... .         ...\n##     9991     chr9 114979995-115095944      - |        9991\n##     9992    chr21   35736323-35743440      + |        9992\n##     9993    chr22   19023795-19109967      - |        9993\n##     9994     chr6   90539619-90584155      + |        9994\n##     9997    chr22   50961997-50964905      - |        9997\n##    -------\n##    seqinfo: 25 sequences (1 circular) from hg19 genome\n\nNow we are ready to test for overlaps. A left join gives us all the overlaps for ranges on the left side (here r). If a range on the left has no overlaps it appears with NA for the metadata columns of the right side ranges. If a range on the left side has multiple overlaps with the right side, it will appear multiple times in the output.\nKeeping reading below on how to deal with this, if it is desired to have statistics on per-range overlaps.\n\nr |&gt; join_overlap_left(g)\n##  GRanges object with 10 ranges and 2 metadata columns:\n##         seqnames            ranges strand | range_id     gene_id\n##            &lt;Rle&gt;         &lt;IRanges&gt;  &lt;Rle&gt; | &lt;factor&gt; &lt;character&gt;\n##     [1]     chr1 34000001-34200000      + |      foo      114784\n##     [2]     chr1 36000001-36200000      - |      bar      127703\n##     [3]     chr1 36000001-36200000      - |      bar       23154\n##     [4]     chr1 36000001-36200000      - |      bar      339488\n##     [5]     chr1 36000001-36200000      - |      bar        5690\n##     [6]     chr1 36000001-36200000      - |      bar       63967\n##     [7]     chr1 36000001-36200000      - |      bar       79932\n##     [8]     chr1 36600001-36700000      - |      boo       27095\n##     [9]     chr1 36600001-36700000      - |      boo       55700\n##    [10]     chr1 36600001-36700000      - |      boo        9967\n##    -------\n##    seqinfo: 1 sequence from an unspecified genome; no seqlengths\n\nIf we want to exclude the zero matches cases, we can use an inner join:\n\nr |&gt; join_overlap_inner(g)\n##  GRanges object with 10 ranges and 2 metadata columns:\n##         seqnames            ranges strand | range_id     gene_id\n##            &lt;Rle&gt;         &lt;IRanges&gt;  &lt;Rle&gt; | &lt;factor&gt; &lt;character&gt;\n##     [1]     chr1 34000001-34200000      + |      foo      114784\n##     [2]     chr1 36000001-36200000      - |      bar      127703\n##     [3]     chr1 36000001-36200000      - |      bar       23154\n##     [4]     chr1 36000001-36200000      - |      bar      339488\n##     [5]     chr1 36000001-36200000      - |      bar        5690\n##     [6]     chr1 36000001-36200000      - |      bar       63967\n##     [7]     chr1 36000001-36200000      - |      bar       79932\n##     [8]     chr1 36600001-36700000      - |      boo       27095\n##     [9]     chr1 36600001-36700000      - |      boo       55700\n##    [10]     chr1 36600001-36700000      - |      boo        9967\n##    -------\n##    seqinfo: 1 sequence from an unspecified genome; no seqlengths\n\n\n\n\n\n\n\nNote\n\n\n\nWhat about other types of overlap? We can specify a distance, called a ‚Äúgap‚Äù, if we want to also find when ranges are near each other, up to a maximum allowed distance. We can also specify the minimum amount of overlapping basepairs. Every overlap function in plyranges has arguments maxgap and minoverlap. For example, to see if ranges are 50kb from each other, we would specify maxgap=5e4. If we want to know if ranges are 50kb from a particular endpoint of another set of ranges, for example TSS, we could perform the operations anchor_5p() followed by mutate(width=1), before overlapping the sets.\n\n\nWe can also perform summarization by columns either in the r or the g object:\n\nr |&gt; \n    join_overlap_inner(g) |&gt; \n    group_by(range_id) |&gt; \n    summarize(count=n())\n##  DataFrame with 3 rows and 2 columns\n##    range_id     count\n##    &lt;factor&gt; &lt;integer&gt;\n##  1      bar         6\n##  2      boo         3\n##  3      foo         1\n\nThis is giving us the same information as the following:\n\nr |&gt; count_overlaps(g)\n##  [1] 1 6 3\n\nWhich can be added to the range data with a mutate call:\n\nr %&gt;% mutate(overlaps = count_overlaps(., g))\n##  GRanges object with 3 ranges and 2 metadata columns:\n##        seqnames            ranges strand | range_id  overlaps\n##           &lt;Rle&gt;         &lt;IRanges&gt;  &lt;Rle&gt; | &lt;factor&gt; &lt;integer&gt;\n##    [1]     chr1 34000001-34200000      + |      foo         1\n##    [2]     chr1 36000001-36200000      - |      bar         6\n##    [3]     chr1 36600001-36700000      - |      boo         3\n##    -------\n##    seqinfo: 1 sequence from an unspecified genome; no seqlengths\n\n\n\n\n\n\n\nNote\n\n\n\nUp to this point, we could have used R‚Äôs native pipe |&gt; in place of the magrittr pipe |&gt;. However the above line won‚Äôt work with R‚Äôs native pipe, even if we use the underscore placeholder _ that goes with R‚Äôs native pipe, instead of the dot placeholder .. This is because R‚Äôs native pipe doesn‚Äôt allow the placeholder to be within a nested expression (count_overlaps called before mutate). In addition, R‚Äôs native pipe only allows use of the placeholder once; sometimes it is convenient to access the incoming object more than once.\n\n\nIf we don‚Äôt care about multiple overlaps, but just want a binary variable that records if there was one or more overlaps or not, we can ask if the count of overlaps is greater than 0:\n\nr %&gt;% mutate(overlaps_any = count_overlaps(., g) &gt; 0)\n##  GRanges object with 3 ranges and 2 metadata columns:\n##        seqnames            ranges strand | range_id overlaps_any\n##           &lt;Rle&gt;         &lt;IRanges&gt;  &lt;Rle&gt; | &lt;factor&gt;    &lt;logical&gt;\n##    [1]     chr1 34000001-34200000      + |      foo         TRUE\n##    [2]     chr1 36000001-36200000      - |      bar         TRUE\n##    [3]     chr1 36600001-36700000      - |      boo         TRUE\n##    -------\n##    seqinfo: 1 sequence from an unspecified genome; no seqlengths\n\nIf we want to keep the information about the gene ranges, we swap the order of the ranges in the command:\n\ng |&gt; join_overlap_inner(r)\n##  GRanges object with 10 ranges and 2 metadata columns:\n##           seqnames            ranges strand |     gene_id range_id\n##              &lt;Rle&gt;         &lt;IRanges&gt;  &lt;Rle&gt; | &lt;character&gt; &lt;factor&gt;\n##    114784     chr1 33979609-34631443      - |      114784      foo\n##    127703     chr1 36179477-36184790      - |      127703      bar\n##     23154     chr1 36023393-36032380      + |       23154      bar\n##     27095     chr1 36602170-36621654      - |       27095      boo\n##    339488     chr1 36038971-36060927      + |      339488      bar\n##     55700     chr1 36621803-36646441      + |       55700      boo\n##      5690     chr1 36035413-36107445      - |        5690      bar\n##     63967     chr1 36197713-36235551      - |       63967      bar\n##     79932     chr1 35899091-36023551      - |       79932      bar\n##      9967     chr1 36690017-36770957      + |        9967      boo\n##    -------\n##    seqinfo: 25 sequences (1 circular) from hg19 genome\n\nIf we want strand specific overlaps, we can add _directed:\n\ng |&gt; join_overlap_inner_directed(r)\n##  GRanges object with 5 ranges and 2 metadata columns:\n##           seqnames            ranges strand |     gene_id range_id\n##              &lt;Rle&gt;         &lt;IRanges&gt;  &lt;Rle&gt; | &lt;character&gt; &lt;factor&gt;\n##    127703     chr1 36179477-36184790      - |      127703      bar\n##     27095     chr1 36602170-36621654      - |       27095      boo\n##      5690     chr1 36035413-36107445      - |        5690      bar\n##     63967     chr1 36197713-36235551      - |       63967      bar\n##     79932     chr1 35899091-36023551      - |       79932      bar\n##    -------\n##    seqinfo: 25 sequences (1 circular) from hg19 genome\n\nBy turning the join around, we have access to the genomic range information about the genes. Now we can compute, e.g.¬†the average genomic extent of the genes (first base to last base), per overlapping range.\n\ng |&gt; join_overlap_inner_directed(r) |&gt; \n    group_by(range_id) |&gt; \n    summarize(count=n(), mean_width=mean(width))\n##  DataFrame with 2 rows and 3 columns\n##    range_id     count mean_width\n##    &lt;factor&gt; &lt;integer&gt;  &lt;numeric&gt;\n##  1      bar         4    59911.8\n##  2      boo         1    19485.0\n\nWhat about \"foo\"? We need to add a complete() call to account for the fact that we are missing those overlaps after the join. We need to call the function explicitly from the tidyr package but by not loading the package we can avoid some function name conflicts with plyranges. Also we need to convert to tibble (explanation follows).\n\nlibrary(tibble)\ng |&gt; \n    join_overlap_inner_directed(r) |&gt; \n    group_by(range_id) |&gt; \n    summarize(count=n(), mean_width=mean(width)) |&gt; \n    as_tibble() |&gt; \n    tidyr::complete(range_id, fill=list(count=0))\n##  # A tibble: 3 √ó 3\n##    range_id count mean_width\n##    &lt;fct&gt;    &lt;int&gt;      &lt;dbl&gt;\n##  1 bar          4     59912.\n##  2 boo          1     19485 \n##  3 foo          0        NA\n\nWhy did we have to convert to tibble before running complete()? This is because metadata columns of GRanges objects are in a format called DataFrame, on which the tidyr / dplyr functions don‚Äôt know how to operate.\nTo access metadata columns of a GRanges object, you can use any of these paradigms:\n\nmcols(r)\n##  DataFrame with 3 rows and 1 column\n##    range_id\n##    &lt;factor&gt;\n##  1      foo\n##  2      bar\n##  3      boo\nmcols(r)$range_id\n##  [1] foo bar boo\n##  Levels: bar boo foo\nr$range_id # this works also\n##  [1] foo bar boo\n##  Levels: bar boo foo\nmcols(r)[[\"range_id\"]] # for programmatic access\n##  [1] foo bar boo\n##  Levels: bar boo foo\n\nBut if you want to work on them in with tidyr / dplyr, you need to first convert to tibble (or data.frame):\n\nmcols(r) |&gt; as_tibble()\n##  # A tibble: 3 √ó 1\n##    range_id\n##    &lt;fct&gt;   \n##  1 foo     \n##  2 bar     \n##  3 boo\n\n\n\n\n\n\n\nNote\n\n\n\nReduce instead of summarize: Above when we used group_by and summarize we lost the original range data. Another option, to preserve the range data, is to use the function reduce_ranges within groups that we define (which can be _directed or not).\n\n\nIf we want to preserve the range information for the r object, we can start with r and proceed to join, group by, and reduce within groups. For an example of reduce_ranges used in the context of a genomic data analysis see Lee, Lawrence, and Love (2020). In order to compute on the gene widths, we have to add that as a metadata column within the join. To keep the no-gene-overlapping ranges in r, we can count when the gene ID is not NA.\n\nLee, Stuart, Michael Lawrence, and Michael I Love. 2020. ‚ÄúFluent Genomics with Plyranges and Tximeta.‚Äù F1000Res. 9 (February): 109.\n\nr |&gt; \n    join_overlap_left_directed(g |&gt; \n    mutate(gene_width=width)) |&gt; \n    group_by(range_id) |&gt; \n    reduce_ranges(\n        count=sum(!is.na(gene_id)),\n        mean_width=mean(gene_width)\n    )\n##  GRanges object with 3 ranges and 3 metadata columns:\n##        seqnames            ranges strand | range_id     count mean_width\n##           &lt;Rle&gt;         &lt;IRanges&gt;  &lt;Rle&gt; | &lt;factor&gt; &lt;integer&gt;  &lt;numeric&gt;\n##    [1]     chr1 34000001-34200000      * |      foo         0         NA\n##    [2]     chr1 36000001-36200000      * |      bar         4    59911.8\n##    [3]     chr1 36600001-36700000      * |      boo         1    19485.0\n##    -------\n##    seqinfo: 1 sequence from an unspecified genome; no seqlengths\n\nHopefully, you‚Äôve seen that there are many routes to compute the types of statistics of interest. The best way to decide which one to use is to think first: what do I want the final output to look like, and do I need to keep track of non-overlapping ranges? This will help dictate the way you set up your code, whether a join or a mutate to just tally a column of overlaps, etc., and whether a complete call is needed to fill in missing levels at the end of the analysis.\n\n\n\n\n Back to top"
  },
  {
    "objectID": "pages/promoter-marks.html",
    "href": "pages/promoter-marks.html",
    "title": "\n3¬† Promoter marks\n",
    "section": "",
    "text": "Objectives\n\n\n\n\nDetermine if tissue-specific promoter marks (e.g.¬†H3K27ac) are often near genes that are expressed in a tissue-specific manner.\n\n\n\nWe will load expression data from the GTEx project (Lonsdale et al. 2013), which gives median expression in TPM for each tissue. We will use H3K27ac ChIP-seq data from the ENCODE project (Dunham et al. 2012).\n\nLonsdale, J. et al. 2013. ‚ÄúThe Genotype-Tissue Expression (GTEx) project.‚Äù Nature Genetics 45 (6): 580‚Äì85.\n\nDunham, I. et al. 2012. ‚ÄúAn integrated encyclopedia of DNA elements in the human genome.‚Äù Nature 489 (7414): 57‚Äì74.\n\nlibrary(tidyr)\nfile &lt;- system.file(\n    \"extdata\", \"GTEx_Analysis_2017-06-05_v8_RNASeQCv1.1.9_gene_median_tpm.gct.gz\", \n    package = \"BiocBook.GRanges\"\n)\ngtex &lt;- read.delim(file, skip=2)\n\nWe select two tissues, bladder and kidney, and convert the data from a wide format into a tidy format.\n\ntissues &lt;- gtex |&gt; \n    dplyr::select(Name, Bladder, Kidney...Cortex) |&gt;\n    dplyr::rename(gene = Name, Kidney = Kidney...Cortex) |&gt;\n    dplyr::mutate(gene = sub(\"\\\\..*\",\"\",gene)) |&gt;\n    pivot_longer(!gene, names_to=\"tissue\", values_to=\"tpm\")\n\nNow define two vectors of genes that are specific to bladder and kidney:\n\nbladder_expr &lt;- tissues |&gt;\n    dplyr::filter(tissue == \"Bladder\" & tpm &gt; 10) |&gt;\n    dplyr::pull(gene)\nkidney_expr &lt;- tissues |&gt;\n    dplyr::filter(tissue == \"Kidney\" & tpm &gt; 10) |&gt;\n    dplyr::pull(gene)\nint &lt;- intersect(bladder_expr, kidney_expr)\nbladder_expr &lt;- setdiff(bladder_expr, int)\nkidney_expr &lt;- setdiff(kidney_expr, int)\n\nNext, use an existing TxDb to locate these genes in the genomes. While we usually recommend to use GENCODE genes for human analysis, because the ENCODE chromatin modification peak files on AnnotationHub are in hg19, we use the UCSC hg19 genes here for simplicity of the code:\n\nlibrary(TxDb.Hsapiens.UCSC.hg19.knownGene)\nlibrary(org.Hs.eg.db)\n\nAdd the ENSEMBL ID and pull out the two tissue-specific sets.\n\ng &lt;- genes(TxDb.Hsapiens.UCSC.hg19.knownGene)\n##    403 genes were dropped because they have exons located on both\n##    strands of the same reference sequence or on more than one reference\n##    sequence, so cannot be represented by a single genomic range.\n##    Use 'single.strand.genes.only=FALSE' to get all the genes in a\n##    GRangesList object, or use suppressMessages() to suppress this\n##    message.\n\n\nlibrary(plyranges)\ng &lt;- g |&gt; \n    mutate(ensembl = mapIds(org.Hs.eg.db, gene_id, \"ENSEMBL\", \"ENTREZID\"))\nbladder_g &lt;- g |&gt; filter(ensembl %in% bladder_expr)\nkidney_g &lt;- g |&gt; filter(ensembl %in% kidney_expr)\n\nFinally we combine the two sets with bind_ranges, and we change the feature size from the whole gene extent (the range from the leftmost exon to rightmost exon), to just the TSS, using anchor_5p and mutate.\n\ntss &lt;- bind_ranges(\n    bladder=bladder_g,\n    kidney=kidney_g,\n    .id=\"gtissue\"\n) |&gt;\n    anchor_5p() |&gt;\n    mutate(width=1)\n\nNow we will obtain the H3K27ac peak sets:\n\nlibrary(AnnotationHub)\n##  Loading required package: BiocFileCache\n##  Loading required package: dbplyr\n##  \n##  Attaching package: 'AnnotationHub'\n##  The following object is masked from 'package:Biobase':\n##  \n##      cache\nah &lt;- AnnotationHub()\n# query(ah, c(\"Homo sapiens\", \"bladder\", \"H3K27ac\", \"narrowPeak\"))\nbladder_pks &lt;- ah[[\"AH44180\"]]\n##  downloading 1 resources\n##  retrieving 1 resource\n##  loading from cache\n##  require(\"rtracklayer\")\n# query(ah, c(\"Homo sapiens\", \"kidney\", \"H3K27ac\", \"narrowPeak\"))\nkidney_pks &lt;- ah[[\"AH43443\"]]\n##  downloading 1 resources\n##  retrieving 1 resource\n##  loading from cache\n\nWe download these and scale so they have the same 90% quantile of signalValue.\n\nninety &lt;- function(x) quantile(x, .9, names=FALSE)\nbladder_pks &lt;- bladder_pks |&gt;\n    mutate(signal = signalValue / ninety(signalValue))\nkidney_pks &lt;- kidney_pks |&gt;\n    mutate(signal = signalValue / ninety(signalValue))\n\nCombine the peaks from bladder and kidney, filter to those with &lt; 0.1% FDR, and center the peak on the summit (the peak column gives the shift from the left side to the summit).\n\npks &lt;- bind_ranges(\n    bladder=bladder_pks,\n    kidney=kidney_pks,\n    .id=\"ptissue\"\n) |&gt;\n    filter(qValue &gt; 3, width &lt;= 1000) |&gt;\n    mutate(start = start + peak) |&gt;\n    dplyr::select(-peak) |&gt;\n    mutate(width = 1)\n\nFinally, once we have two tidy range sets, we can perform the analysis by a join, followed by two lines that take care of multiple overlaps, followed by two lines that give us our tallies of interest.\nIt appears that tissue-specific peaks are enriched near the tissue-specific genes for both bladder and kidney.\n\ntss |&gt;\n    join_overlap_left(pks, maxgap=500) |&gt;\n    group_by(ptissue) |&gt; # within peak tissue...\n    filter(!duplicated(gene_id)) |&gt; # ...just take the first overlap per gene\n    group_by(gtissue, ptissue) |&gt;\n    summarize(count = n())\n##  DataFrame with 6 rows and 3 columns\n##    gtissue     ptissue     count\n##      &lt;Rle&gt; &lt;character&gt; &lt;integer&gt;\n##  1 bladder     bladder      2163\n##  2 bladder      kidney      1568\n##  3 bladder          NA       859\n##  4  kidney     bladder       103\n##  5  kidney      kidney       208\n##  6  kidney          NA       242\n\nThe above number could also be found with four countOverlaps calls, by considering all four pairs of overlaps of the two sets of genes and peaks.\nAnother way to avoid counting overlaps more than once per gene is to use the plyranges function, n_distinct():\n\ntss |&gt;\n    join_overlap_left(pks, maxgap=500) |&gt;\n    group_by(gtissue, ptissue) |&gt;\n    summarize(count = n_distinct(gene_id))\n##  DataFrame with 6 rows and 3 columns\n##    gtissue     ptissue     count\n##      &lt;Rle&gt; &lt;character&gt; &lt;integer&gt;\n##  1 bladder     bladder      2163\n##  2 bladder      kidney      1568\n##  3 bladder          NA       859\n##  4  kidney     bladder       103\n##  5  kidney      kidney       208\n##  6  kidney          NA       242\n\nIf we want more information per gene, e.g.¬†suppose we want to compute the average signal per gene of peaks nearby, we need to group twice, once also by gene ID, and the second time integrating over gene ID. While here we add a few more lines of code, performing such an operation with base Bioconductor functions would require adding code to perform the loops, adding many intermediate variables to store results, etc.\n\ntss |&gt;\n    join_overlap_left(pks, maxgap=500) |&gt;\n    group_by(gtissue, ptissue, gene_id) |&gt; # need per gene stats\n    summarize(num_overlaps = n(), signal = mean(signal)) |&gt;\n    as_tibble() |&gt; # DataFrame to tibble for further processing\n    group_by(gtissue, ptissue) |&gt;\n    summarize(\n        sum_any_overlaps = sum(num_overlaps &gt; 0),\n        mean_signal=mean(signal)\n    )\n##  `summarise()` has grouped output by 'gtissue'. You can override using the\n##  `.groups` argument.\n##  # A tibble: 6 √ó 4\n##  # Groups:   gtissue [2]\n##    gtissue ptissue sum_any_overlaps mean_signal\n##    &lt;chr&gt;   &lt;chr&gt;              &lt;int&gt;       &lt;dbl&gt;\n##  1 bladder bladder             2163       1.18 \n##  2 bladder kidney              1568       0.929\n##  3 bladder &lt;NA&gt;                 859      NA    \n##  4 kidney  bladder              103       0.991\n##  5 kidney  kidney               208       0.714\n##  6 kidney  &lt;NA&gt;                 242      NA\n\nQuestion:\nWhat‚Äôs wrong with this analysis?\n\nWe didn‚Äôt figure out the expressed promoter, we just looked at the left or rightmost isoform (for + or - strand genes, respectively).\n\n\n\n\n\n Back to top"
  },
  {
    "objectID": "pages/bootstrap-overlap.html",
    "href": "pages/bootstrap-overlap.html",
    "title": "\n4¬† Bootstrap overlap\n",
    "section": "",
    "text": "Objectives\n\n\n\n\nDetermine if one set of peaks are overlapping another set of peaks more or less than expected when comparing to sets of null features\n\n\n\nThe null features can be generated in a variety of ways ‚Äì here we will generate them by resampling large blocks of one of the peak sets.\nThe motivation for sampling blocks, instead of placing features uniformly along the chromosome (‚Äúshuffling‚Äù), is to better preserve inter-feature distances, because genomic features tend to cluster in the genome, even after considering things like excluded regions.\nThis technique of generating null feature sets is called block bootstrap resampling, and we will use the nullranges implementation of the block bootstrapping algorithm (Mu et al. 2023) to generate the null features, followed by overlap analysis with plyranges (Lee, Cook, and Lawrence 2019).\n\nMu, Wancen, Eric S Davis, Stuart Lee, Mikhail G Dozmorov, Douglas H Phanstiel, and Michael I Love. 2023. ‚ÄúbootRanges: flexible generation of null sets of genomic ranges for hypothesis testing.‚Äù Bioinformatics 39 (5). https://doi.org/10.1093/bioinformatics/btad190.\n\nLee, Stuart, Dianne Cook, and Michael Lawrence. 2019. ‚ÄúPlyranges: A Grammar of Genomic Data Transformation.‚Äù Genome Biol. 20 (1): 4.\n\nBickel, Peter J., Nathan Boley, James B. Brown, Haiyan Huang, and Nancy R. Zhang. 2010. ‚ÄúSubsampling Methods for Genomic Inference.‚Äù The Annals of Applied Statistics 4 (4): 1660‚Äì97. https://doi.org/10.1214/10-{AOAS363}.\nThe approach used in nullranges to generate bootstrap ranges closely follows the GSC method proposed by Bickel et al. (2010).\nNote that an alternative approach for null hypothesis comparisons is to define a set of covariate-matched ranges, an approach also implemented in the nullranges package and described in Davis et al. (2023). For examples of using matching with ranges, see the related articles here.\n\nDavis, Eric S, Wancen Mu, Stuart Lee, Mikhail G Dozmorov, Michael I Love, and Douglas H Phanstiel. 2023. ‚ÄúmatchRanges: generating null hypothesis genomic ranges via covariate-matched sampling.‚Äù Bioinformatics 39 (5). https://doi.org/10.1093/bioinformatics/btad197.\n\nDunham, I. et al. 2012. ‚ÄúAn integrated encyclopedia of DNA elements in the human genome.‚Äù Nature 489 (7414): 57‚Äì74.\nWe start by loading the ENCODE kidney and bladder H3K27ac ChIP-seq peaks used in the previous analysis (Dunham et al. 2012).\n\nlibrary(AnnotationHub)\n##  Loading required package: BiocGenerics\n##  \n##  Attaching package: 'BiocGenerics'\n##  The following objects are masked from 'package:stats':\n##  \n##      IQR, mad, sd, var, xtabs\n##  The following objects are masked from 'package:base':\n##  \n##      anyDuplicated, aperm, append, as.data.frame, basename, cbind,\n##      colnames, dirname, do.call, duplicated, eval, evalq, Filter,\n##      Find, get, grep, grepl, intersect, is.unsorted, lapply, Map,\n##      mapply, match, mget, order, paste, pmax, pmax.int, pmin,\n##      pmin.int, Position, rank, rbind, Reduce, rownames, sapply,\n##      setdiff, sort, table, tapply, union, unique, unsplit, which.max,\n##      which.min\n##  Loading required package: BiocFileCache\n##  Loading required package: dbplyr\nah &lt;- AnnotationHub()\nkidney_pks &lt;- ah[[\"AH43443\"]]\n##  loading from cache\n##  require(\"rtracklayer\")\nbladder_pks &lt;- ah[[\"AH44180\"]]\n##  loading from cache\n\nWe will additionally obtain an excluded region set, so that we avoid placing bootstrap features into regions of the genome that don‚Äôt typically have features. A variety of possible exclude lists are provided by the excluderanges packages and available via AnnotationHub. Here we will use the hg19.Crawford.wgEncodeDukeMapabilityRegionsExcludable regions, as they are available for hg19, which is the genome used with the peak sets.\n\nlibrary(BiocBook.GRanges)\n##  Loading required package: BiocBook\n##  \n##  Attaching package: 'BiocBook'\n##  The following object is masked from 'package:graphics':\n##  \n##      title\ndata(\"exclude\", package =\"BiocBook.GRanges\")\nexclude\n##  GRanges object with 1649 ranges and 2 metadata columns:\n##           seqnames            ranges strand |         name     score\n##              &lt;Rle&gt;         &lt;IRanges&gt;  &lt;Rle&gt; |  &lt;character&gt; &lt;numeric&gt;\n##       [1]     chr1       10468-11447      * |         TAR1      1000\n##       [2]     chr1     564463-570304      * |         chrM      1000\n##       [3]     chr1     724137-727026      * |     (GAATG)n      1000\n##       [4]     chr1     825006-825115      * |     BSR/Beta      1000\n##       [5]     chr1   1815107-1815204      * | LSU-rRNA_Hsa      1000\n##       ...      ...               ...    ... .          ...       ...\n##    [1645]     chrY 28555026-28555353      * |         TAR1      1000\n##    [1646]     chrY 28784131-28819345      * |     (GAATG)n      1000\n##    [1647]     chrY 58819367-58917648      * |     (CATTC)n      1000\n##    [1648]     chrY 58971913-58997782      * |     (CATTC)n      1000\n##    [1649]     chrY 59361267-59362785      * |         TAR1      1000\n##    -------\n##    seqinfo: 56 sequences (1 circular) from hg19 genome\n\nTo make the code more generic, we will rename the kidney peaks to x and the bladder peaks to y. We will be looking for overlaps with features in x as the query set: how many of the features in x overlap features in y?\nThe following code reduces our analysis to looking only at standard chromosomes, excluding the mitochondrial genome (too small for including in the block bootstrap).\n\nlibrary(GenomeInfoDb)\nx &lt;- kidney_pks\ny &lt;- bladder_pks\nx &lt;- keepStandardChromosomes(x)\nseqlevels(x, pruning.mode=\"coarse\") &lt;- setdiff(seqlevels(x), \"chrM\")\nseqlevels(y, pruning.mode=\"coarse\") &lt;- seqlevels(x)\nseqlevels(exclude, pruning.mode=\"coarse\") &lt;- seqlevels(x)\n\nWe are mostly concerned with avoiding placing bootstrapped features in large regions in the exclude list, so we subset the exclude list to features larger than 500 bp. Why do we have plyranges:: in front of filter? This is because there is a function in the ensembldb package that is also called filter, so it‚Äôs a bit safer if we are using both packages to use the package name.\n\nlibrary(plyranges)\nexclude &lt;- exclude |&gt;\n    plyranges::filter(width(exclude) &gt;= 500)\n\nWe also subset to the peaks for kidney and bladder which have q-value less than 0.001 and signal value greater than 9 (these are arbitrary filter values, just for demonstration).\nFor further analysis, we will need the features in y to be sorted, for the bootstrapping, here we sort both sets.\n\nq_thr &lt;- 3\ns_thr &lt;- 9\nx &lt;- x |&gt; \n    plyranges::filter(qValue &gt; q_thr & signalValue &gt; s_thr) |&gt;\n    sort()\ny &lt;- y |&gt; \n    plyranges::filter(qValue &gt; q_thr & signalValue &gt; s_thr) |&gt;\n    sort()\n\nNow we can assess how many overlaps we observed between x and y:\n\nobs &lt;- x %&gt;% mutate(n_overlaps = count_overlaps(., y))\nobs |&gt; summarize(total = sum(n_overlaps))\n##  DataFrame with 1 row and 1 column\n##        total\n##    &lt;integer&gt;\n##  1      5073\ntable( obs$n_overlaps )\n##  \n##     0    1    2    3    4    6 \n##  9453 3966  486   39    3    1\n\nWe can check if any of the features of y fall in the excluded regions:\n\ny %&gt;% mutate(n_overlaps = count_overlaps(., exclude)) |&gt;\n    summarize(total = sum(n_overlaps))\n##  DataFrame with 1 row and 1 column\n##        total\n##    &lt;integer&gt;\n##  1         0\n\nThe following chunk of code does the bootstrapping of features in y. Here we subset first to metadata columns of interest (an id variable that we create, and the signal value which we rename to signal).\n\npks_to_boot &lt;- y %&gt;%\n  mutate(id = seq_along(.)) |&gt;\n  plyranges::select(id, signal = signalValue)\n\nThe bootRanges function returns the bootstrap feature sets combined into one GRanges object ‚Äì this tidy format facilitates downstream analysis as we will see. The bootstrap iteration is stored in the iter metadata column.\n\nlibrary(nullranges)\nR &lt;- 30 # number of iterations\nset.seed(5) # set seed for reproducibility\nboots &lt;- bootRanges(pks_to_boot, blockLength=5e5, R=R, exclude=exclude)\nboots\n##  BootRanges object with 174764 ranges and 3 metadata columns:\n##             seqnames            ranges strand |        id    signal  iter\n##                &lt;Rle&gt;         &lt;IRanges&gt;  &lt;Rle&gt; | &lt;integer&gt; &lt;numeric&gt; &lt;Rle&gt;\n##         [1]     chr1   2011397-2011809      * |       931  14.42934     1\n##         [2]     chr1   2011973-2012399      * |       932  17.57052     1\n##         [3]     chr1   2012505-2013073      * |       933   9.64691     1\n##         [4]     chr1   2503670-2505748      * |      3752  20.84181     1\n##         [5]     chr1   2505855-2507134      * |      3753  15.29241     1\n##         ...      ...               ...    ... .       ...       ...   ...\n##    [174760]     chrY 57499850-57501632      * |      5141  10.09210    30\n##    [174761]     chrY 57937341-57937960      * |      1062  15.98656    30\n##    [174762]     chrY 58145916-58146540      * |       264  15.23097    30\n##    [174763]     chrY 58146662-58147585      * |       265  12.26661    30\n##    [174764]     chrY 58214091-58214746      * |       266   9.69322    30\n##    -------\n##    seqinfo: 24 sequences from hg19 genome\n\nThe default use above of the exclude argument is to drop bootstrapped ranges that overlap the exclude list.\nWe can examine properties of permuted y over iterations, and compare to the original y. To do so, we first add the original features as iter=0.\n\ncombined &lt;- pks_to_boot |&gt; \n    mutate(iter=0) |&gt;\n    bind_ranges(boots) |&gt; \n    plyranges::select(iter)\n\nThen compute summaries:\n\nlibrary(tibble)\nstats &lt;- combined |&gt; \n    group_by(iter) |&gt;\n    summarize(\n        n = n(),\n        sum_width=sum(width)/1e6\n    ) |&gt;\n    as_tibble()\n\nOriginal y vs bootstrap:\n\nstats[1,]\n##  # A tibble: 1 √ó 3\n##    iter      n sum_width\n##    &lt;fct&gt; &lt;int&gt;     &lt;dbl&gt;\n##  1 0      5838      5.07\nsummary(stats[-1,])\n##        iter          n          sum_width    \n##   1      : 1   Min.   :5595   Min.   :4.843  \n##   2      : 1   1st Qu.:5723   1st Qu.:4.968  \n##   3      : 1   Median :5825   Median :5.042  \n##   4      : 1   Mean   :5825   Mean   :5.057  \n##   5      : 1   3rd Qu.:5910   3rd Qu.:5.130  \n##   6      : 1   Max.   :6053   Max.   :5.295  \n##   (Other):24\n\nWe can also look at distributions of various aspects, e.g.¬†here the width of features, across a few of the bootstraps and the original feature set y.\n\nlibrary(ggplot2)\nlibrary(ggridges)\ncombined |&gt; \n    plyranges::filter(iter %in% 0:5) |&gt;\n    plyranges::select(iter) |&gt;\n    as_tibble() |&gt;\n    mutate(type = ifelse(iter == 0, \"original\", \"boot\")) |&gt;\n    ggplot(aes(log10(width), iter, fill=type)) +\n    geom_density_ridges(alpha = 0.75) +\n    geom_text(\n        data=head(stats),\n        aes(x=2.25, y=iter, label=paste0(\"n=\",n), fill=NULL),\n        vjust=1.5\n    )\n\n\n\n\n\n\n\nTo compute overlap with the null features, we need the complete() function from the tidyr package. We saw complete() before ‚Äì this is used in the case that one of the iterations has no overlaps. In this case, we need to record the 0 value for proper inference and plots downstream. It is rare we would have no overlaps with so many features as we have in x and y but it‚Äôs good practice to leave the complete() as part of the workflow so the code works correctly in all cases.\nThe overlap per iteration of the bootstrap is accomplished by a series of plyranges / dplyr commands (we switch to dplyr halfway through, after the as_tibble() call).\n\nlibrary(tidyr)\nnull &lt;- x |&gt; \n    join_overlap_inner(boots) |&gt;\n    group_by(iter) |&gt;\n    summarize(n_overlaps = n()) |&gt;\n    as_tibble() |&gt;\n    complete(iter, fill=list(n_overlaps = 0))\nhead(null)\n##  # A tibble: 6 √ó 2\n##    iter  n_overlaps\n##    &lt;fct&gt;      &lt;int&gt;\n##  1 1             60\n##  2 2             60\n##  3 3             76\n##  4 4             51\n##  5 5             39\n##  6 6             66\n\n\nsum( obs$n_overlaps )\n##  [1] 5073\n\nThe observed number of overlaps is about two orders of magnitude more than the bootstrapped number, which makes sense as two tissues would be expected to share a number of similar regulatory regions (as marked by H3K27ac) ‚Äì more so than randomly placed genomic features, even after accounting for excluded regions and feature clustering.\n\nggplot(null, aes(n_overlaps)) +\n    geom_histogram(binwidth=5) +\n    ggtitle(\"bootstrap overlaps\")\n\n\n\n\n\n\n\nWhat could be improved with this analysis?\nNote that in the above chunks where we count overlaps, we are doubly (or triply, etc.) counting features in x if they hit more than one feature in y or boots. We can count statistics per x feature by adding another group_by into the stream of operations. This also allows us to do more complex operations, such as computing the maximum signal value for the overlapping features in y per feature in x:\nFirst add an ID variable to keep track of x features:\n\nx &lt;- x |&gt; mutate(x_id = seq_along(x))\n\nThen perform an inner join, and group by the new x ID:\n\nobs &lt;- x |&gt; join_overlap_inner(pks_to_boot) |&gt;\n    group_by(x_id) |&gt;\n    summarize(\n        num_overlaps = n(),\n        max_signal = max(signal)\n    )\nsum( obs$num_overlaps &gt; 0 )\n##  [1] 4495\nsummary( obs$max_signal )\n##     Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n##    9.002  10.281  12.025  13.029  14.725  35.211\n\nFor the bootstrap ranges overlap step, we also need to add iter to the initial group_by, so we count per x feature and per iteration of the bootstrap:\n\nnull &lt;- x |&gt; \n    join_overlap_inner(boots) |&gt;\n    group_by(x_id, iter) |&gt;\n    summarize(num_overlaps = n()) |&gt;\n    as_tibble() |&gt;\n    group_by(iter) |&gt;\n    summarize(any_hits = sum(num_overlaps &gt; 0)) |&gt;\n    complete(iter, fill=list(any_hits = 0))\nhead(null)\n##  # A tibble: 6 √ó 2\n##    iter  any_hits\n##    &lt;fct&gt;    &lt;int&gt;\n##  1 1           55\n##  2 2           55\n##  3 3           68\n##  4 4           50\n##  5 5           37\n##  6 6           63\n\nStill, we are seeing much more overlap in the observed data than in the bootstrap data:\n\nsum( obs$num_overlaps &gt; 0 ) /\n    mean(null$any_hits)\n##  [1] 76.75014\n\nThe above code chunk then avoids double counting. We could also have made other per-x-feature statistics in the summarize step after the initial group_by, such as maximum signal of overlapping features.\nWhat other ways could we have done this analysis? Suppose we don‚Äôt just want the count of overlaps, but the rate of overlaps from the y perspective, keeping track of the variable number of features per bootstrap.\nWe demonstrate one approach to obtain this rate for the bootstraps:\n\nx_thin &lt;- x |&gt; plyranges::select(x_id)\nnull &lt;- boots |&gt; \n    plyranges::select(id, iter) |&gt;\n    join_overlap_inner(x_thin) |&gt;\n    group_by(id, iter) |&gt;\n    summarize(num_overlaps = n()) |&gt;\n    as_tibble() |&gt;\n    group_by(iter) |&gt;\n    summarize(any_hits = sum(num_overlaps &gt; 0)) |&gt;\n    complete(iter, fill=list(any_hits = 0))\n\nNow combine with the per-iteration total count:\n\ntotals &lt;- boots |&gt; \n    group_by(iter) |&gt;\n    summarize(total=n()) |&gt;\n    as_tibble()\nnull |&gt; dplyr::left_join(totals) |&gt;\n    mutate(rate = any_hits/total)\n##  Joining with `by = join_by(iter)`\n##  # A tibble: 30 √ó 4\n##    iter  any_hits total    rate\n##    &lt;fct&gt;    &lt;int&gt; &lt;int&gt;   &lt;dbl&gt;\n##  1 1           59  6031 0.00978\n##  2 2           58  5710 0.0102 \n##  3 3           73  5758 0.0127 \n##  4 4           50  5927 0.00844\n##  5 5           37  5713 0.00648\n##  6 6           59  5888 0.0100 \n##  # ‚Ñπ 24 more rows\n\n\n\n\n\n Back to top"
  },
  {
    "objectID": "pages/snp-position-in-peaks.html",
    "href": "pages/snp-position-in-peaks.html",
    "title": "\n5¬† SNP position in peaks\n",
    "section": "",
    "text": "Objectives\n\n\n\n\nDetermine the position of a set of SNPs in peaks, that is, determine the relative positions of those SNPs that overlap the peaks\n\n\n\nWe again will use the ENCODE kidney H3K27ac ChIP-seq peaks used in the previous analysis (Dunham et al. 2012). We will create some artificial SNPs: this analysis could generalize to any time that we have two ranges, where we are interested in the relative position of one set of ranges (SNPs) within the other set of ranges (peaks).\n\nDunham, I. et al. 2012. ‚ÄúAn integrated encyclopedia of DNA elements in the human genome.‚Äù Nature 489 (7414): 57‚Äì74.\n\nlibrary(AnnotationHub)\n##  Loading required package: BiocGenerics\n##  \n##  Attaching package: 'BiocGenerics'\n##  The following objects are masked from 'package:stats':\n##  \n##      IQR, mad, sd, var, xtabs\n##  The following objects are masked from 'package:base':\n##  \n##      anyDuplicated, aperm, append, as.data.frame, basename, cbind,\n##      colnames, dirname, do.call, duplicated, eval, evalq, Filter,\n##      Find, get, grep, grepl, intersect, is.unsorted, lapply, Map,\n##      mapply, match, mget, order, paste, pmax, pmax.int, pmin,\n##      pmin.int, Position, rank, rbind, Reduce, rownames, sapply,\n##      setdiff, sort, table, tapply, union, unique, unsplit, which.max,\n##      which.min\n##  Loading required package: BiocFileCache\n##  Loading required package: dbplyr\nah &lt;- AnnotationHub()\nkidney_pks &lt;- ah[[\"AH43443\"]]\n##  loading from cache\n##  require(\"rtracklayer\")\n\nWe will filter the peaks to standard chromosomes, and include the same cutoffs we used in the previous analysis.\n\nsuppressPackageStartupMessages(library(GenomeInfoDb))\npks &lt;- kidney_pks\npks &lt;- keepStandardChromosomes(pks)\n\n\nsuppressPackageStartupMessages({\n  library(dplyr)\n  library(tibble)\n  library(plyranges)\n})\nq_thr &lt;- 3\ns_thr &lt;- 9\npks &lt;- pks |&gt; \n    filter(qValue &gt; q_thr & signalValue &gt; s_thr) |&gt;\n    sort()\n\nA histogram of peak width:\n\nlibrary(ggplot2)\npks |&gt; as_tibble() |&gt;\n    filter(width &lt; 5000) |&gt;\n    ggplot(aes(width)) + \n    geom_histogram()\n##  `stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\n\n\nLet‚Äôs subset to peaks that are less than 2000 in width:\n\npks &lt;- pks |&gt; filter(width &lt; 2000)\n\nNow, we may be interested in SNPs that are associated with regulatory function. While we could find these from a database of chromatin QTL or functionally validated variants, here we will just create a simulated set of SNPs for demonstration.\n\nset.seed(1)\nsnps &lt;- pks[sample(1:length(pks), 2000)] |&gt;\n    anchor_5p() |&gt;\n    mutate(start=start + floor(runif(2000,0,width))) |&gt;\n    mutate(width=1)\nsnps\n##  GRanges object with 2000 ranges and 6 metadata columns:\n##           seqnames    ranges strand |        name     score signalValue\n##              &lt;Rle&gt; &lt;IRanges&gt;  &lt;Rle&gt; | &lt;character&gt; &lt;numeric&gt;   &lt;numeric&gt;\n##       [1]     chr1 222886667      * |    Rank_786       943    28.06788\n##       [2]    chr17   1251302      * |  Rank_11154       238    10.45065\n##       [3]     chr9  75179753      * |   Rank_8060       305    12.52016\n##       [4]     chrX  70401571      * |   Rank_9602       266    11.38197\n##       [5]    chr20  37615472      * |  Rank_14922       190     9.52741\n##       ...      ...       ...    ... .         ...       ...         ...\n##    [1996]     chr9  14316343      * |  Rank_15136       188     9.11715\n##    [1997]    chr18  74800298      * |  Rank_15685       181     9.02626\n##    [1998]    chr19  52641902      * |   Rank_2464       606    19.64891\n##    [1999]     chr2 128642862      * |  Rank_15514       184     9.18719\n##    [2000]     chr6 151005236      * |  Rank_13672       203     9.07738\n##              pValue    qValue      peak\n##           &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt;\n##       [1]   94.3437   89.9679       267\n##       [2]   23.8843   21.0424       458\n##       [3]   30.5751   27.5376       616\n##       [4]   26.6991   23.7679       455\n##       [5]   19.0203   16.3297       414\n##       ...       ...       ...       ...\n##    [1996]   18.8452   16.1647       461\n##    [1997]   18.1808   15.5192       173\n##    [1998]   60.6790   56.9445      1281\n##    [1999]   18.4512   15.7837       125\n##    [2000]   20.3511   17.6170       887\n##    -------\n##    seqinfo: 25 sequences (1 circular) from hg19 genome\n\nThese should all overlap peaks:\n\nsnps %&gt;%\n    mutate(n_overlaps = count_overlaps(., pks)) |&gt;\n    summarize(tab=table(n_overlaps))\n##  DataFrame with 1 row and 2 columns\n##    tab.n_overlaps  tab.Freq\n##          &lt;factor&gt; &lt;integer&gt;\n##  1              1      2000\n\nWe now have a bit of a hack for this analysis: we add the start position and width of the peak as addition columns of metadata. This is because otherwise, we will lose the start position when we perform the overlap of SNPs in peaks, and we need it for later.\n\npks_trim &lt;- pks |&gt; \n  select(name) |&gt;\n  mutate(peak_start=start, peak_width=width)\n\nWe can then obtain overlaps of SNPs with peaks, and add the relative position of the SNP within the peak extent. We use 1-based indexing, such that if the SNP is the same as the leftmost basepair of the peak, it gets counted as position 1.\n\no &lt;- snps |&gt; \n    join_overlap_inner(pks_trim) |&gt;\n    mutate(\n        rel_pos = start - peak_start + 1,\n        rel_frac = (rel_pos - 1) / (peak_width - 1 )\n    )\n\nCheck our expectations about these new columns:\n\nall(o$rel_pos &gt;= 1)\n##  [1] TRUE\nall(o$rel_frac &gt;= 0)\n##  [1] TRUE\nall(o$rel_frac &lt;= 1)\n##  [1] TRUE\n\nFinally, we can compute a histogram of where the SNPs fall in the peaks:\n\no |&gt; \n    as_tibble() |&gt;\n    ggplot(aes(rel_frac)) + \n    geom_histogram(breaks=0:10/10)\n\n\n\n\n\n\n\nNow stratifying by width of peak:\n\nquantile(o$peak_width, 0:3/3)\n##         0% 33.33333% 66.66667%      100% \n##   246.0000  813.3333 1289.6667 1998.0000\no |&gt;\n    mutate(\n        width_bin = cut(\n            peak_width,\n            breaks=c(200,800,1300,2000),\n            include.lowest=TRUE\n        )\n    ) |&gt;\n    as_tibble() |&gt;\n    ggplot(aes(rel_frac)) + \n    geom_histogram(breaks=0:10/10) + \n    facet_wrap(~width_bin)\n\n\n\n\n\n\n\n\n\n\n\n Back to top"
  },
  {
    "objectID": "pages/gene-plots.html",
    "href": "pages/gene-plots.html",
    "title": "\n6¬† Gene plots\n",
    "section": "",
    "text": "Objectives\n\n\n\n\nFor a region of the genome, find peaks near the TSS of genes and then plot their signal strength per gene, stratifying by the tissue origin of the peak.\n\n\n\nWe start by loading the pre-downloaded peaks ranges:\n\nlibrary(BiocBook.GRanges)\n##  Loading required package: BiocBook\n##  \n##  Attaching package: 'BiocBook'\n##  The following object is masked from 'package:graphics':\n##  \n##      title\ndata(\"exclude\", package = \"BiocBook.GRanges\")\nexclude\n##  Loading required package: GenomicRanges\n##  Loading required package: stats4\n##  Loading required package: BiocGenerics\n##  \n##  Attaching package: 'BiocGenerics'\n##  The following objects are masked from 'package:stats':\n##  \n##      IQR, mad, sd, var, xtabs\n##  The following objects are masked from 'package:base':\n##  \n##      anyDuplicated, aperm, append, as.data.frame, basename, cbind,\n##      colnames, dirname, do.call, duplicated, eval, evalq, Filter,\n##      Find, get, grep, grepl, intersect, is.unsorted, lapply, Map,\n##      mapply, match, mget, order, paste, pmax, pmax.int, pmin,\n##      pmin.int, Position, rank, rbind, Reduce, rownames, sapply,\n##      setdiff, sort, table, tapply, union, unique, unsplit, which.max,\n##      which.min\n##  Loading required package: S4Vectors\n##  \n##  Attaching package: 'S4Vectors'\n##  The following object is masked from 'package:utils':\n##  \n##      findMatches\n##  The following objects are masked from 'package:base':\n##  \n##      expand.grid, I, unname\n##  Loading required package: IRanges\n##  Loading required package: GenomeInfoDb\n##  GRanges object with 1649 ranges and 2 metadata columns:\n##           seqnames            ranges strand |         name     score\n##              &lt;Rle&gt;         &lt;IRanges&gt;  &lt;Rle&gt; |  &lt;character&gt; &lt;numeric&gt;\n##       [1]     chr1       10468-11447      * |         TAR1      1000\n##       [2]     chr1     564463-570304      * |         chrM      1000\n##       [3]     chr1     724137-727026      * |     (GAATG)n      1000\n##       [4]     chr1     825006-825115      * |     BSR/Beta      1000\n##       [5]     chr1   1815107-1815204      * | LSU-rRNA_Hsa      1000\n##       ...      ...               ...    ... .          ...       ...\n##    [1645]     chrY 28555026-28555353      * |         TAR1      1000\n##    [1646]     chrY 28784131-28819345      * |     (GAATG)n      1000\n##    [1647]     chrY 58819367-58917648      * |     (CATTC)n      1000\n##    [1648]     chrY 58971913-58997782      * |     (CATTC)n      1000\n##    [1649]     chrY 59361267-59362785      * |         TAR1      1000\n##    -------\n##    seqinfo: 56 sequences (1 circular) from hg19 genome\n\nLikewise, we want to use hg19 genes again to match the hg19 peaks:\n\nlibrary(TxDb.Hsapiens.UCSC.hg19.knownGene)\nlibrary(org.Hs.eg.db)\ng &lt;- genes(TxDb.Hsapiens.UCSC.hg19.knownGene)\n\nAdding gene symbols:\n\nlibrary(plyranges)\ng &lt;- g |&gt;\n    mutate(gene_name = mapIds(org.Hs.eg.db, gene_id, \"SYMBOL\", \"ENTREZID\"))\n\nFind a region of the genome near a kidney-specific gene:\n\ng |&gt; \n    filter(gene_name == \"UMOD\")\n##  GRanges object with 1 range and 2 metadata columns:\n##         seqnames            ranges strand |     gene_id   gene_name\n##            &lt;Rle&gt;         &lt;IRanges&gt;  &lt;Rle&gt; | &lt;character&gt; &lt;character&gt;\n##    7369    chr16 20344373-20364037      - |        7369        UMOD\n##    -------\n##    seqinfo: 93 sequences (1 circular) from hg19 genome\nregion &lt;- data.frame(\n    seqnames=\"chr16\", \n    start=20e6,\n    end=21e6\n) |&gt;\n    as_granges()\n\nCombine the bladder and kidney peaks, and select certain columns:\n\nlibrary(AnnotationHub)\n##  Loading required package: BiocFileCache\n##  Loading required package: dbplyr\n##  \n##  Attaching package: 'AnnotationHub'\n##  The following object is masked from 'package:Biobase':\n##  \n##      cache\nah &lt;- AnnotationHub()\nkidney_pks &lt;- ah[[\"AH43443\"]]\n##  loading from cache\n##  require(\"rtracklayer\")\nbladder_pks &lt;- ah[[\"AH44180\"]]\n##  loading from cache\npks &lt;- bind_ranges(\n    bladder=bladder_pks,\n    kidney=kidney_pks,\n    .id=\"tissue\"\n) |&gt;\n    select(signal=signalValue, tissue)\n\nFinally, we perform the overlap join, locating peaks within 100kb of the TSS of the gene.\n\ng_with_pks &lt;- g |&gt;\n    anchor_5p() |&gt;\n    mutate(width=1) |&gt;\n    filter_by_overlaps(region) |&gt;\n    join_overlap_inner(pks, maxgap=1e5)\ng_with_pks$tissue |&gt; table()\n##  \n##  bladder  kidney \n##      208     337\n\nWe can construct a faceted set of boxplots, first we make a tibble of data for our plot.\n\nlibrary(dplyr)\nlibrary(tibble)\ndat &lt;- g_with_pks |&gt;\n    select(gene_name, signal, tissue, .drop_ranges=TRUE) |&gt;\n    as_tibble()\n\nThen pass the data to ggplot (we could have just passed the data directly, but we plan to re-use the data).\n\nlibrary(ggplot2)\ndat |&gt;\n    ggplot(aes(tissue, signal)) +\n    geom_boxplot() + \n    facet_wrap(~gene_name)\n\n\n\n\n\n\n\nNow let‚Äôs try to plot these in context, using plotgardener (Kramer et al. 2022). First we filter down to the peaks near UMOD.\n\nKramer, Nicole E, Eric S Davis, Craig D Wenger, Erika M Deoudes, Sarah M Parker, Michael I Love, and Douglas H Phanstiel. 2022. ‚ÄúPlotgardener: cultivating precise multi-panel figures in R.‚Äù Bioinformatics 38 (7): 2042‚Äì45. https://doi.org/10.1093/bioinformatics/btac057.\n\numod &lt;- g |&gt;\n    filter(gene_name == \"UMOD\") |&gt;\n    anchor_5p() |&gt;\n    mutate(width=1)\npks_to_plot &lt;- pks |&gt;\n    filter_by_overlaps(umod, maxgap=1e5) |&gt;\n    anchor_center() |&gt;\n    mutate(width=1e4) # to make the ranges more visible\n\nWe then define a color scheme for the tissue variable, and make a ggplot object which will be added to our genome plots.\n\ncols &lt;- function(n) palette.colors(n+2)[-c(1,3)]\ncol_vec &lt;- cols(2)\nnames(col_vec) &lt;- unique(dat$tissue)\np &lt;- dat |&gt;\n    filter(gene_name == \"UMOD\") |&gt;\n    ggplot(aes(tissue, signal, col=tissue)) +\n    # here we set a seed for jitter\n    geom_point(size=.5, position=position_jitter(width=.1, seed=5)) +\n    scale_color_manual(values = col_vec)\n\nWe then create some parameters that will be shared across a number of the plots in plotgardener.\n\nlibrary(plotgardener)\npar &lt;- pgParams(\n    chrom = \"chr16\", \n    chromstart = round((start(umod) - 1e5)/1e5)*1e5,\n    chromend = round((start(umod) + 4e5)/1e5)*1e5,\n    assembly = \"hg19\", just = c(\"left\", \"bottom\")\n)\n\nFinally we put all the pieces together on a page (for laying out the plot, first use showGuides=TRUE).\n\npageCreate(width = 5, height = 3, showGuides = FALSE)\nplotGenes(\n    params = par, x = 0.5, y = 2.5, width = 4, height = .75\n)\nplotRanges(\n    pks_to_plot,\n    fill = colorby(\"tissue\", palette=cols),\n    params = par, x = 0.5, y = 1.75, width = 4, height = 1.75\n)\nplotGenomeLabel(\n    params = par, x = 0.5, y = 2.5, length = 4,\n    just = c(\"left\", \"top\")\n)\nplotGG(\n    p + ggtitle(\"UMOD\"), \n    params = par, x = 2.25, y = 1.75, width = 2.5, height = 1.75\n)\n\n\n\n\n\n\n\n\n\n\n\n Back to top"
  },
  {
    "objectID": "pages/rnaseq-eda.html",
    "href": "pages/rnaseq-eda.html",
    "title": "\n7¬† RNA-seq EDA\n",
    "section": "",
    "text": "Objectives\n\n\n\n\nLearn how to make basic EDA plots (plotting scaled counts) of RNA-seq data using tidy-style verbs\n\n\n\nThe tidybulk Bioconductor package and associated tidy transcriptomics ecosystem (tidySummarizedExperiment, tidySingleCell, tidyseurat, etc.) provide a bridge between the SummarizedExperiment-style representation of matrix data with attached metadata, to the tidy-style representation of data (one row per observation). For more details on the package, check out the tidybulk website, and the publication: Mangiola et al. (2021).\n\nMangiola, Stefano, Ramyar Molania, Ruining Dong, Maria A. Doyle, and Anthony T. Papenfuss. 2021. ‚ÄúTidybulk: An r Tidy Framework for Modular Transcriptomic Data Analysis.‚Äù Genome Biology 22 (1): 42. https://doi.org/10.1186/s13059-020-02233-7.\nHere we will briefly examine the difference between tidy manipulation of these matrix-style objects compared to how these objects would be manipulated in other Bioconductor workflows (e.g.¬†DESeq2, edgeR, or limma workflows). As you will see, there are multiple ways to generate the same or similar exploratory plots and analyses. we recommend to consider which is more appropriate to your purpose. For package code, you may prefer to have fewer dependencies, going with core Bioconductor objects and packages. For scripting, the ‚Äúfluent‚Äù and piped style of tidybulk may be preferable, and easier for others to read and modify your code at a future date.\nHere we just compare code for some basic tasks, scaling counts and performing DE with DESeq2. However, note that tidybulk has many functionalities implemented, including dimension reduction and visualization (PCA, MDS, tSNE, UMAP), clustering, gene set testing, cell type composition analysis and cell abundance testing, unwanted variation modeling, imputation, etc.\nStart by loading this RNA-seq dataset from the following paper by King and Klose (2017): ‚ÄúThe pioneer factor OCT4 requires the chromatin remodeller BRG1 to support gene regulatory element function in mouse embryonic stem cells‚Äù. The experiment focused on OCT4 as it is a ‚Äúcore pluripotency transcription factor‚Äù which ‚Äúoccupies sites that would otherwise be inaccessible and is required to shape the occupancy of additional pluripotency transcription factors‚Äù.\n\nKing, Hamish W, and Robert J Klose. 2017. ‚ÄúThe Pioneer Factor OCT4 Requires the Chromatin Remodeller BRG1 to Support Gene Regulatory Element Function in Mouse Embryonic Stem Cells.‚Äù Edited by Irwin Davidson. eLife 6 (March): e22631. https://doi.org/10.7554/eLife.22631.\nIn this experiment, transcription in mouse embryonic stem cells (ESC) was compared with and without OCT4. This was done using a conditional mouse ESC line where treatment with a compound leads to loss of OCT4 expression. The experiment also involved the same approach to another transcription factor BRG1, but we focus here on the OCT4 samples.\nFirst we load the metadata about the samples:\n\nlibrary(oct4)\ndir &lt;- system.file(\"extdata\", package=\"oct4\")\ncoldata &lt;- read.csv(file.path(dir,\"coldata.csv\"))\ncoldata\n##          names line condition\n##  1  SRX2236945 OCT4     untrt\n##  2  SRX2236946 OCT4     untrt\n##  3  SRX2236947 OCT4     untrt\n##  4  SRX2236948 OCT4       trt\n##  5  SRX2236949 OCT4       trt\n##  6  SRX2236950 OCT4       trt\n##  7  SRX2236951 BRG1     untrt\n##  8  SRX2236952 BRG1     untrt\n##  9  SRX2236953 BRG1     untrt\n##  10 SRX2236954 BRG1       trt\n##  11 SRX2236955 BRG1       trt\n##  12 SRX2236956 BRG1       trt\ncoldata$files &lt;- file.path(dir, \"quants\", coldata$names, \"quant.sf.gz\")\n\nRead in the count data with tximeta, which automatically imports the information about the gene provenance (which transcripts were used to quantify the gene and isoform abundance). We then summarize the quantification to the gene-level, and add the gene SYMBOL.\n\nlibrary(tximeta)\nse &lt;- tximeta(coldata)\n##  importing quantifications\n##  reading in files with read_tsv\n##  1 2 3 4 5 6 7 8 9 10 11 12 \n##  found matching transcriptome:\n##  [ GENCODE - Mus musculus - release M20 ]\n##  useHub=TRUE: checking for TxDb via 'AnnotationHub'\n##  did not find matching TxDb via 'AnnotationHub'\n##  building TxDb with 'GenomicFeatures' package\n##  Import genomic features from the file as a GRanges object ... OK\n##  Prepare the 'metadata' data frame ... OK\n##  Make the TxDb object ...\n##  Warning in .get_cds_IDX(mcols0$type, mcols0$phase): The \"phase\" metadata column contains non-NA values for features of\n##    type stop_codon. This information was ignored.\n##  OK\n##  generating transcript ranges\n##  fetching genome info for GENCODE\n##  Loading required package: BiocGenerics\n##  \n##  Attaching package: 'BiocGenerics'\n##  \n##  The following objects are masked from 'package:stats':\n##  \n##      IQR, mad, sd, var, xtabs\n##  \n##  The following objects are masked from 'package:base':\n##  \n##      anyDuplicated, aperm, append, as.data.frame, basename, cbind,\n##      colnames, dirname, do.call, duplicated, eval, evalq, Filter,\n##      Find, get, grep, grepl, intersect, is.unsorted, lapply, Map,\n##      mapply, match, mget, order, paste, pmax, pmax.int, pmin,\n##      pmin.int, Position, rank, rbind, Reduce, rownames, sapply,\n##      setdiff, sort, table, tapply, union, unique, unsplit, which.max,\n##      which.min\n##  \n##  Loading required package: S4Vectors\n##  Loading required package: stats4\n##  \n##  Attaching package: 'S4Vectors'\n##  \n##  The following object is masked from 'package:utils':\n##  \n##      findMatches\n##  \n##  The following objects are masked from 'package:base':\n##  \n##      expand.grid, I, unname\ngse &lt;- summarizeToGene(se)\n##  loading existing TxDb created: 2023-08-12 17:10:40\n##  Loading required package: GenomicFeatures\n##  Loading required package: GenomicRanges\n##  Loading required package: AnnotationDbi\n##  Loading required package: Biobase\n##  Welcome to Bioconductor\n##  \n##      Vignettes contain introductory material; view with\n##      'browseVignettes()'. To cite Bioconductor, see\n##      'citation(\"Biobase\")', and for packages 'citation(\"pkgname\")'.\n##  \n##  obtaining transcript-to-gene mapping from database\n##  generating gene ranges\n##  gene ranges assigned by total range of isoforms, see `assignRanges`\n##  summarizing abundance\n##  summarizing counts\n##  summarizing length\n##  summarizing inferential replicates\nlibrary(org.Mm.eg.db)\n##  \ngse &lt;- addIds(gse, \"SYMBOL\")\n##  it appears the rows are gene IDs, setting 'gene' to TRUE\n##  mapping to new IDs using org.Mm.eg.db\n##  if all matching IDs are desired, and '1:many mappings' are reported,\n##  set multiVals='list' to obtain all the matching IDs\n##  'select()' returned 1:many mapping between keys and columns\n\nFor this workflow, we don‚Äôt need the inferential replicates (about uncertainty regarding the quantification), so we keep just the counts, abundances (TPM), and gene lengths. We also manipulate the metadata a little bit.\n\nlibrary(SummarizedExperiment)\n##  Loading required package: MatrixGenerics\n##  Loading required package: matrixStats\n##  \n##  Attaching package: 'matrixStats'\n##  The following objects are masked from 'package:Biobase':\n##  \n##      anyMissing, rowMedians\n##  \n##  Attaching package: 'MatrixGenerics'\n##  The following objects are masked from 'package:matrixStats':\n##  \n##      colAlls, colAnyNAs, colAnys, colAvgsPerRowSet, colCollapse,\n##      colCounts, colCummaxs, colCummins, colCumprods, colCumsums,\n##      colDiffs, colIQRDiffs, colIQRs, colLogSumExps, colMadDiffs,\n##      colMads, colMaxs, colMeans2, colMedians, colMins, colOrderStats,\n##      colProds, colQuantiles, colRanges, colRanks, colSdDiffs, colSds,\n##      colSums2, colTabulates, colVarDiffs, colVars, colWeightedMads,\n##      colWeightedMeans, colWeightedMedians, colWeightedSds,\n##      colWeightedVars, rowAlls, rowAnyNAs, rowAnys, rowAvgsPerColSet,\n##      rowCollapse, rowCounts, rowCummaxs, rowCummins, rowCumprods,\n##      rowCumsums, rowDiffs, rowIQRDiffs, rowIQRs, rowLogSumExps,\n##      rowMadDiffs, rowMads, rowMaxs, rowMeans2, rowMedians, rowMins,\n##      rowOrderStats, rowProds, rowQuantiles, rowRanges, rowRanks,\n##      rowSdDiffs, rowSds, rowSums2, rowTabulates, rowVarDiffs,\n##      rowVars, rowWeightedMads, rowWeightedMeans, rowWeightedMedians,\n##      rowWeightedSds, rowWeightedVars\n##  The following object is masked from 'package:Biobase':\n##  \n##      rowMedians\nassayNames(gse)\n##   [1] \"counts\"    \"abundance\" \"length\"    \"infRep1\"   \"infRep2\"   \"infRep3\"  \n##   [7] \"infRep4\"   \"infRep5\"   \"infRep6\"   \"infRep7\"   \"infRep8\"   \"infRep9\"  \n##  [13] \"infRep10\"  \"infRep11\"  \"infRep12\"  \"infRep13\"  \"infRep14\"  \"infRep15\" \n##  [19] \"infRep16\"  \"infRep17\"  \"infRep18\"  \"infRep19\"  \"infRep20\"\nassays(gse) &lt;- assays(gse)[1:3]\ngse$rep &lt;- rep(1:3, 4)\ncolnames(gse) &lt;- paste(gse$line,gse$condition,gse$rep,sep=\"-\")\nassay(gse, \"counts\") &lt;- round(assay(gse, \"counts\")) # for DE consistency\n\nThe dataset looks like this (remember it has untreated and treated samples for both OCT4 and BRG1).\n\ngse\n##  class: RangedSummarizedExperiment \n##  dim: 53697 12 \n##  metadata(7): tximetaInfo quantInfo ... txdbInfo assignRanges\n##  assays(3): counts abundance length\n##  rownames(53697): ENSMUSG00000000001.4 ENSMUSG00000000003.15 ...\n##    ENSMUSG00000117654.1 ENSMUSG00000117655.1\n##  rowData names(3): gene_id tx_ids SYMBOL\n##  colnames(12): OCT4-untrt-1 OCT4-untrt-2 ... BRG1-trt-2 BRG1-trt-3\n##  colData names(4): names line condition rep\n\nWe will be interested in the gene set from the Gene Ontology project, which describes maintenance of pluripotency. We can extra this from the mouse organism data package with the following three lines of code:\n\nlibrary(AnnotationDbi)\nlibrary(org.Mm.eg.db)\n# pluripotency\ntab &lt;- AnnotationDbi::select(org.Mm.eg.db, \"GO:0019827\", \"SYMBOL\", \"GO\")\n##  'select()' returned 1:many mapping between keys and columns\ntab &lt;- tab[!duplicated(tab$SYMBOL),]\npluri &lt;- tab$SYMBOL\n\nNow we start with tidybulk code, comparing in turn to base R. Loading tidySummarizedExperiment allows us to operate on the gse object using familiar ‚Äútidy‚Äù verbs, thanks to an abstraction described in the tidySummarizedExperiment documentation. We filter the samples that correspond to the OCT4 experiment, and then modify the sample names. Samples are referred to with the special .sample string, while features are referred to with .feature, so here we create a new variable to plot the samples sample_name.\n\nlibrary(tidySummarizedExperiment)\nlibrary(dplyr)\nlibrary(stringr)\noct4 &lt;- gse |&gt;\n    filter(line == \"OCT4\") |&gt;\n    mutate(\n        sample_name = .sample |&gt; str_remove(\"OCT4-\") %&gt;% factor(levels = unique(.)),\n        condition = condition |&gt; factor(c(\"untrt\",\"trt\"))\n    )\n\nNote, the third line in the mutate call uses the unique function to set the levels: the consequence of this is that the sample_name factor will have levels in the order in which they are present in the current character vector and not alphabetical.\n\noct4\n##  # A SummarizedExperiment-tibble abstraction: 322,182 √ó 18\n##  # [90mFeatures=53697 | Samples=6 | Assays=counts, abundance, length[0m\n##    .feature              .sample      counts abundance length names      line \n##    &lt;chr&gt;                 &lt;chr&gt;         &lt;dbl&gt;     &lt;dbl&gt;  &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;\n##  1 ENSMUSG00000000001.4  OCT4-untrt-1   2920    16.6    2953. SRX2236945 OCT4 \n##  2 ENSMUSG00000000003.15 OCT4-untrt-1      0     0       589. SRX2236945 OCT4 \n##  3 ENSMUSG00000000028.15 OCT4-untrt-1   1906    19.0    1688. SRX2236945 OCT4 \n##  4 ENSMUSG00000000031.16 OCT4-untrt-1   9044    74.8    2034. SRX2236945 OCT4 \n##  5 ENSMUSG00000000037.16 OCT4-untrt-1    132     0.826  2688. SRX2236945 OCT4 \n##  6 ENSMUSG00000000049.11 OCT4-untrt-1      0     0       943. SRX2236945 OCT4 \n##  # ‚Ñπ 44 more rows\n##  # ‚Ñπ 11 more variables: condition &lt;fct&gt;, rep &lt;int&gt;, sample_name &lt;fct&gt;, ‚Ä¶\n\ntidybulk provides access to many steps in bulk analysis, including filtering and count scaling. For details on what is happening behind the scene, see the help, e.g.¬†?keep_abundant describes that it makes use of edgeR::filterByExpr.\n\nlibrary(tidybulk)\noct4 &lt;- oct4 |&gt;\n    keep_abundant(factor_of_interest = condition) |&gt;\n    scale_abundance(method=\"RLE\") # DESeq2 scaling\n\nIt is straightforward to pipe the data directly into plots:\n\nlibrary(ggplot2)\noct4 |&gt;\n    ggplot(aes(sample_name, counts_scaled + 1)) +\n    geom_boxplot() +\n    scale_y_log10()\n\n\n\n\n\n\n\nFor comparing code, let‚Äôs pull out the genes that remain:\n\ngene_idx &lt;- oct4 |&gt; \n    pivot_transcript() |&gt; \n    pull(.feature)\nhead(gene_idx)\n##  [1] \"ENSMUSG00000000001.4\"  \"ENSMUSG00000000028.15\" \"ENSMUSG00000000031.16\"\n##  [4] \"ENSMUSG00000000037.16\" \"ENSMUSG00000000056.7\"  \"ENSMUSG00000000058.6\"\n\nThe equivalent code in DESeq2. Understanding this code requires knowledge that boxplot plots columns of a matrix.\n\nlibrary(DESeq2)\ngse_sub &lt;- gse[ gene_idx , gse$line == \"OCT4\" ]\ngse_sub$condition &lt;- factor(gse_sub$condition)\ndds &lt;- gse_sub |&gt;\n    DESeqDataSet(~condition) |&gt;\n    estimateSizeFactors()\n##  using counts and average transcript lengths from tximeta\n##  using 'avgTxLength' from assays(dds), correcting for library size\nboxplot(counts(dds, normalized=TRUE) + 1, log=\"y\")\n\n\n\n\n\n\n\nWe can also make more interesting plots. E.g. for the genes involved in pluripotency, make a line plot, highlighting OCT4. In addition, center the log counts for each gene (subtract the mean of log counts across samples).\n\noct4 |&gt;\n    filter(SYMBOL %in% pluri) |&gt;\n    mutate(logcounts = log10(counts_scaled + 1)) |&gt;\n    mutate(Oct4 = ifelse(SYMBOL == \"Pou5f1\", \"red\", \"black\")) |&gt;\n    group_by(.feature) |&gt;\n    mutate(logcounts = logcounts - mean(logcounts)) |&gt;\n    ungroup() |&gt;\n    ggplot(aes(sample_name, logcounts, group=.feature, color=Oct4)) +\n    geom_point() +\n    geom_line() +\n    scale_color_identity()\n##  tidySummarizedExperiment says: A data frame is returned for independent data analysis.\n\n\n\n\n\n\n\nThe equivalent code for base R requires defining more intermediate variables and control flow code (the for loop). While there‚Äôs nothing particularly right or wrong about the two choices, the above prioritizes the operations in a way that is human readable. In some cases, e.g.¬†performing linear algebra operations on matrices, base R code may prove to be more efficient, which is a consideration for what to use in package source code.\n\npluri_idx &lt;- mcols(dds)$SYMBOL %in% pluri\nmat &lt;- log10(counts(dds, normalized=TRUE)[pluri_idx,] + 1)\nmat &lt;- mat - rowMeans(mat)\nhilite &lt;- rownames(dds)[which(mcols(dds)$SYMBOL == \"Pou5f1\")]\nplot(mat[1,], type=\"n\", ylim=c(-1,1), xlab=\"samples\", ylab=\"logcounts\")\nfor (i in 1:nrow(mat)) {\n  col &lt;- ifelse(rownames(mat)[i] == hilite, \"red\", \"black\")\n  points(mat[i,], type=\"b\", col=col)\n}\n\n\n\n\n\n\n\nWe can test for differential expression with DESeq2:\n\nres &lt;- dds[gene_idx,] |&gt;\n    DESeq() |&gt;\n    results()\n##  using pre-existing normalization factors\n##  estimating dispersions\n##  gene-wise dispersion estimates\n##  mean-dispersion relationship\n##  final dispersion estimates\n##  fitting model and testing\n\nOr equivalently with tidybulk:\n\noct4 &lt;- oct4 |&gt;\n    test_differential_abundance(~condition, method=\"deseq2\")\n##  =====================================\n##  tidybulk says: All testing methods use raw counts, irrespective of if scale_abundance\n##  or adjust_abundance have been calculated. Therefore, it is essential to add covariates\n##  such as batch effects (if applicable) in the formula.\n##  =====================================\n##  using counts and average transcript lengths from tximeta\n##  \n##  estimating size factors\n##  \n##  using 'avgTxLength' from assays(dds), correcting for library size\n##  \n##  estimating dispersions\n##  \n##  gene-wise dispersion estimates\n##  \n##  mean-dispersion relationship\n##  \n##  final dispersion estimates\n##  \n##  fitting model and testing\n##  \n##  tidybulk says: to access the raw results (fitted GLM) do `attr(..., \"internals\")$deseq2`\n##  This message is displayed once per session.\ntidy_res &lt;- oct4 |&gt;\n    pivot_transcript()\n\nBecause we have filtered the two objects identically, we obtain the same test results:\n\nall.equal(rownames(res), tidy_res$.feature)\n##  [1] TRUE\ntable(base_sig = res$padj &lt; .1, tidy_sig = tidy_res$padj &lt; .1)\n##          tidy_sig\n##  base_sig FALSE  TRUE\n##     FALSE 17965     0\n##     TRUE      0  3512\n\nFinally, we build up to a more interesting plot. Suppose we now want to split the genes involved in pluripotency by the DE result (the significance and LFC), and then add the gene symbol to the side.\nWe begin by building the dataset:\n\nplot_data &lt;- oct4 |&gt;\n    filter(SYMBOL %in% pluri) |&gt;\n    mutate(logcounts = log10(counts_scaled + 1)) |&gt;\n    mutate(Oct4 = ifelse(SYMBOL == \"Pou5f1\", \"red\", \"black\")) |&gt;\n    group_by(.feature) |&gt;\n    mutate(logcounts = logcounts - mean(logcounts)) |&gt;\n    ungroup() |&gt;\n    mutate(\n        gene_type = case_when(\n            padj &lt; .1 & log2FoldChange &gt; 0 ~ \"up\",\n            padj &lt; .1 & log2FoldChange &lt; 0 ~ \"down\",\n            TRUE ~ \"null\"\n        )\n    )\n##  tidySummarizedExperiment says: A data frame is returned for independent data analysis.\n\nNow we repeat the code from before, but now faceting by gene_type. Furthermore, we use geom_text_repel to add labels to the right side.\n\nlibrary(ggrepel)\nplot_data |&gt;\n    filter(gene_type != \"null\") |&gt;\n    ggplot(aes(sample_name, logcounts, group=.feature, color=Oct4)) +\n    geom_point() +\n    geom_line() +\n    geom_text_repel(\n        data=plot_data |&gt;\n            filter(sample_name == \"trt-3\", gene_type != \"null\"),\n        aes(sample_name, logcounts, label=SYMBOL),\n        nudge_x=.5, seed=1, max.overlaps=Inf) +\n    scale_color_identity() +\n    facet_wrap(~gene_type) +\n    scale_x_discrete(expand = expansion(add = 2)) +\n    xlab(\"sample\")\n\n\n\n\n\n\n\n\n\n\n\n Back to top"
  },
  {
    "objectID": "pages/many-genomic-models.html",
    "href": "pages/many-genomic-models.html",
    "title": "\n8¬† Many genomic models\n",
    "section": "",
    "text": "Objectives\n\n\n\n\nLearn how to run many models (think many linear regressions or many machine learning models) in a tidy framework, by ‚Äúnesting‚Äù the genomic dataset and storing the fitted models as rows of a new column in the nested table\n\n\n\nIn the previous chapter, we looked at some basic filtering and plotting operations, with perhaps the most interesting operation being a grouped centering of the gene expression.\nHere we will explore a special case of tidy-style operations on a genomic dataset, in particular a SummarizedExperiment, where we want to run multiple, similar models across groups of features (or likewise, the same could be done to rows).\nFor some other references to these types of operations, you can check out:\n\n\nThe ‚Äúmany models‚Äù chapter of R for Data Science by Wickham and Grolemund (2017), which introduced the basics of how to run many models in a tidy framework\nThe nest documentation in tidyr\n\nThe tidymodels package\n\n\nWickham, Hadley, and Garrett Grolemund. 2017. R for Data Science: Import, Tidy, Transform, Visualize, and Model Data. 1st ed. Paperback; O‚ÄôReilly Media. http://r4ds.had.co.nz/.\nGiven the size of genomic data, and the way in which tidySummarizedExperiment abstracts the link between data (assay) and metadata (rowData and colData), we will consider in this chapter how the speed of the operations may be impacted by our choices in setting up the code. In the end, you may find that a more standard way of running the analyses (e.g.¬†using base R/Bioc) is more efficient, depending on the cost incurred by the nesting operation, which we will describe shortly.\nWe will work with a Bioconductor experiment package fission which contains a dataset created by Leong et al. (2014) PMC4050258:\n\nLeong, Hui Sun, Keren Dawson, Chris Wirth, Yaoyong Li, Yvonne Connolly, Duncan L Smith, Caroline R M Wilkinson, and Crispin J Miller. 2014. ‚ÄúA Global Non-Coding RNA System Modulates Fission Yeast Protein Levels in Response to Stress.‚Äù Nat. Commun. 5 (1): 3947.\n\nHere we integrate high-throughput RNA sequencing and label-free quantitative protein mass spectrometry to investigate global changes in transcript and protein levels in the fission yeast stress response.\n\nThe experiment considers fission yeast of two strains, wild-type (WT) and atf21\\(\\Delta\\), but here we will not focus on these two strains but just lump the data together, to increase our sample size for the point of building the models.\n\nlibrary(fission)\ndata(fission)\nse &lt;- fission\ncolData(se)\n##  DataFrame with 36 rows and 4 columns\n##               strain   minute replicate          id\n##             &lt;factor&gt; &lt;factor&gt;  &lt;factor&gt; &lt;character&gt;\n##  GSM1368273       wt       0         r1     wt_0_r1\n##  GSM1368274       wt       0         r2     wt_0_r2\n##  GSM1368275       wt       0         r3     wt_0_r3\n##  GSM1368276       wt       15        r1    wt_15_r1\n##  GSM1368277       wt       15        r2    wt_15_r2\n##  ...             ...      ...       ...         ...\n##  GSM1368304      mut      120        r2  mut_120_r2\n##  GSM1368305      mut      120        r3  mut_120_r3\n##  GSM1368306      mut      180        r1  mut_180_r1\n##  GSM1368307      mut      180        r2  mut_180_r2\n##  GSM1368308      mut      180        r3  mut_180_r3\n\nWe again use tidybulk to filter to abundant genes and scale counts for library size:\n\nlibrary(tidybulk)\nse &lt;- se |&gt;\n    keep_abundant(factor_of_interest = strain) |&gt;\n    scale_abundance()\nassayNames(se)\n##  [1] \"counts\"        \"counts_scaled\"\n\nWe make a PCA plot of the log scaled counts, to get a sense for how the samples vary. Note that minute 0 and 180 are similar, as the cells have not yet responded to the stimulus at minute 0. We will later remove these samples for simple modeling.\n\npca &lt;- se |&gt;\n    reduce_dimensions(method=\"PCA\")\n##  Getting the 500 most variable genes\n##  Fraction of variance explained by the selected principal components\n##  # A tibble: 2 √ó 2\n##    `Fraction of variance`    PC\n##                     &lt;dbl&gt; &lt;int&gt;\n##  1                  0.293     1\n##  2                  0.182     2\n##  tidybulk says: to access the raw results do `attr(..., \"internals\")$PCA`\nlibrary(ggplot2)\npca |&gt;\n    pivot_sample() |&gt;\n    ggplot(aes(PC1, PC2, shape=strain, color=minute)) +\n    geom_point()\n\n\n\n\n\n\n\nWe can plot the gene with the most contribution to PC1. Here we will begin working with the data as a tidySE (shortened name for tidySummarizedExperiment):\n\nmax_pc1 &lt;- which.max(abs(attr(pca, \"internals\")[[\"PCA\"]][[\"rotation\"]][,\"PC1\"]))\nmax_pc1\n##  SPBC839.06 \n##           8\nlibrary(tidySummarizedExperiment)\nse |&gt;\n    filter(.feature == names(max_pc1)) |&gt;\n    ggplot(aes(minute, counts_scaled + 1, color=strain, group=strain)) +\n    geom_point() +\n    stat_smooth(se=FALSE) +\n    scale_y_log10() +\n    ggtitle( rowData(se)[names(max_pc1),\"symbol\"] )\n\n\n\n\n\n\n\nNow, let‚Äôs consider a hypothetical analysis question: can we predict the minute (quantitatively) using the log gene expression of a genes in a neighborhood on the chromosome. While this is mostly a contrived question, for the purposes of demonstrating nesting of genomic datasets, you could imagine that there might be modules of responsive genes positioned along the chromosome, and that a prediction task is one way to identify genes that are related to an aspect of the experimental design.\nThe steps will be:\n\nCreate centered log scaled counts\nCreate ‚Äúblocks‚Äù of genes, by tiling the genome and labeling the genes that fall within the same tile\n‚ÄúNest‚Äù the tidySE such that we can operate on the blocks of genes together\nRun a series of models, each time predicting the minute variable using the expression of the genes in the block\nEvaluate these models (here simply looking at in-sample training error)\n\n‚ÄúNesting‚Äù a dataset is an operation, similar to group_by, where a variable is used to perform grouped operations. We will specify to nest all the data (columns) besides the grouping variable, such that we end up with a tibble that looks like:\n\n\ngrouping variable\ndata\n\n\n\nvalue1\nRngdSmmE\n\n\nvalue2\nRngdSmmE\n\n\n‚Ä¶\n‚Ä¶\n\n\n\nHence, for every row of the SummarizedExperiment that has value1 for the grouping variable, we will have a subsetted SummarizedExperiment (‚Äúranged‚Äù refers to the face that it is rowRanges).\nLet‚Äôs start with the first task. We compute logcounts and then center and scale these values. Likewise, we turn the minute variable from a factor into a numeric, and scale from 0 to 1. These changes would help us compare coefficients across gene later.\n\nse &lt;- se |&gt;\n  mutate(\n    logcounts = log2(counts_scaled + 1),\n    logcounts = (logcounts - mean(logcounts))/sd(logcounts)\n)\nse &lt;- se |&gt;\n    mutate(time = as.numeric(as.character(minute)) / 180)\nse\n##  # A SummarizedExperiment-tibble abstraction: 210,996 √ó 20\n##  # [90mFeatures=5861 | Samples=36 | Assays=counts, counts_scaled, logcounts[0m\n##    .feature    .sample    counts counts_scaled logcounts strain minute\n##    &lt;chr&gt;       &lt;chr&gt;       &lt;int&gt;         &lt;dbl&gt;     &lt;dbl&gt; &lt;fct&gt;  &lt;fct&gt; \n##  1 SPAC212.09c GSM1368273     23          23.1    -1.70  wt     0     \n##  2 SPAC212.04c GSM1368273     37          37.1    -1.42  wt     0     \n##  3 SPAC977.11  GSM1368273    155         155.     -0.581 wt     0     \n##  4 SPAC977.13c GSM1368273     19          19.0    -1.81  wt     0     \n##  5 SPAC977.15  GSM1368273     91          91.2    -0.896 wt     0     \n##  6 SPAC977.16c GSM1368273    184         184.     -0.479 wt     0     \n##  # ‚Ñπ 44 more rows\n##  # ‚Ñπ 13 more variables: replicate &lt;fct&gt;, id &lt;chr&gt;, TMM &lt;dbl&gt;, ‚Ä¶\n\nFor demonstration, we will work with just the first chromosome: I.\nFor our task of modeling the design using gene expression, in blocks along the genome, we need to create tiles to determine which genes to group together. To do so, we need to know how long the chromosomes are. The original publication states:\n\nSequencing reads were aligned to the fission yeast genome (PomBase database release 11)\n\nUsually we would look for the length of chromosomes from a source that hosts the reference (e.g.¬†UCSC genome lengths can be obtained using Seqinfo). In this case, I wasn‚Äôt able to find information about this particular release, so I just guess the length of the chromosome using the gene with the largest coordinate:\n\nlibrary(plyranges)\nrowRanges(se) |&gt;\n    filter(seqnames == \"I\") |&gt;\n    summarize(max(end))\n##  DataFrame with 1 row and 1 column\n##     max.end.\n##    &lt;integer&gt;\n##  1   5556768\ngenes_to_keep &lt;- rowRanges(se) |&gt;\n    filter(seqnames == \"I\") |&gt;\n    names()\n\nWe now filter the se object to remove the 0 time point, and to keep just the features on chromosome I.\n\nse0 &lt;- se # save the original object\nse &lt;- se |&gt;\n    filter(time != 0) |&gt;\n    filter(.feature %in% genes_to_keep)\n\nTo make tiles on chromosome I, we just need to specify the extent (here I plug in the largest gene coordinate):\n\ntiles &lt;- data.frame(seqnames=\"I\",start=1,end=5.6e6) |&gt;\n    as_granges() |&gt;\n    tile_ranges(width=1e5) |&gt;\n    select(-partition) %&gt;%\n    mutate(tile = seq_along(.))\ntiles\n##  GRanges object with 56 ranges and 1 metadata column:\n##         seqnames          ranges strand |      tile\n##            &lt;Rle&gt;       &lt;IRanges&gt;  &lt;Rle&gt; | &lt;integer&gt;\n##     [1]        I        1-100000      * |         1\n##     [2]        I   100001-200000      * |         2\n##     [3]        I   200001-300000      * |         3\n##     [4]        I   300001-400000      * |         4\n##     [5]        I   400001-500000      * |         5\n##     ...      ...             ...    ... .       ...\n##    [52]        I 5100001-5200000      * |        52\n##    [53]        I 5200001-5300000      * |        53\n##    [54]        I 5300001-5400000      * |        54\n##    [55]        I 5400001-5500000      * |        55\n##    [56]        I 5500001-5600000      * |        56\n##    -------\n##    seqinfo: 1 sequence from an unspecified genome; no seqlengths\n\nWe now determine which tile the genes fall in (using TSS only, so that genes fall in a single tile). We can add this data back onto the tidySE using a left_join:\n\nranges_tiled &lt;- rowRanges(se) |&gt;\n    anchor_5p() |&gt;\n    mutate(width=1) |&gt;\n    join_overlap_left(tiles) %&gt;%\n    mutate(.feature = names(.)) |&gt;\n    select(tile, .feature, .drop_ranges=TRUE) |&gt;\n    as_tibble()\nnrow(se) == nrow(ranges_tiled)\n##  [1] TRUE\n# combining the tile information with the SE\nse &lt;- se |&gt; left_join(ranges_tiled)\n##  Joining with `by = join_by(.feature)`\n##  Joining with `by = join_by(.feature)`\n\nTypically we have a little less than 50 genes per tile:\n\nsummary(as.vector(table(rowData(se)$tile)))\n##     Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n##     5.00   44.00   49.00   46.98   51.25   59.00\n\nNext, we want to create a nested table, where tidySE objects are grouped by tile and placed within a column of the table. There are a few choices on how to proceed. One option would be to pivot_wider the tidySE, as in this chunk below:\n\nse |&gt;\n    filter(.feature %in% rownames(se)[1:5]) |&gt;\n    select(.sample, strain, time, .feature, logcounts) |&gt;\n    pivot_wider(names_from = .feature, values_from = logcounts)\n##  tidySummarizedExperiment says: A data frame is returned for independent data analysis.\n##  # A tibble: 30 √ó 8\n##    .sample    strain   time SPAC212.09c SPAC212.04c SPAC977.11 SPAC977.13c\n##    &lt;chr&gt;      &lt;fct&gt;   &lt;dbl&gt;       &lt;dbl&gt;       &lt;dbl&gt;      &lt;dbl&gt;       &lt;dbl&gt;\n##  1 GSM1368276 wt     0.0833      -1.30       -1.51      -0.705      -1.85 \n##  2 GSM1368277 wt     0.0833      -1.03       -2.01      -1.19       -1.27 \n##  3 GSM1368278 wt     0.0833      -0.993      -2.11      -1.13       -1.88 \n##  4 GSM1368279 wt     0.167       -0.802      -1.40      -0.690      -0.324\n##  5 GSM1368280 wt     0.167       -0.574      -1.06      -0.847      -0.399\n##  6 GSM1368281 wt     0.167       -0.685      -0.880     -0.685      -0.571\n##  # ‚Ñπ 24 more rows\n##  # ‚Ñπ 1 more variable: SPAC977.15 &lt;dbl&gt;\n\nThis ends up being a bit slower than just extracting the information with assay and transposing it.\nFirst let‚Äôs create our nested dataset:\n\nlibrary(purrr)\nnested &lt;- se |&gt;\n    nest(data = -tile)\nnested\n##  # A tibble: 56 √ó 2\n##     tile data           \n##    &lt;int&gt; &lt;list&gt;         \n##  1     1 &lt;RngdSmmE[,30]&gt;\n##  2     2 &lt;RngdSmmE[,30]&gt;\n##  3     3 &lt;RngdSmmE[,30]&gt;\n##  4     4 &lt;RngdSmmE[,30]&gt;\n##  5     5 &lt;RngdSmmE[,30]&gt;\n##  6     6 &lt;RngdSmmE[,30]&gt;\n##  # ‚Ñπ 50 more rows\n\nNow, by row, extract out and transpose log scaled counts:\n\nnested &lt;- nested |&gt;\n    mutate(trainx = map(data, ~ {\n        t(assay(.x, \"logcounts\"))\n    }))\nnested\n##  # A tibble: 56 √ó 3\n##     tile data            trainx         \n##    &lt;int&gt; &lt;list&gt;          &lt;list&gt;         \n##  1     1 &lt;RngdSmmE[,30]&gt; &lt;dbl [30 √ó 20]&gt;\n##  2     2 &lt;RngdSmmE[,30]&gt; &lt;dbl [30 √ó 54]&gt;\n##  3     3 &lt;RngdSmmE[,30]&gt; &lt;dbl [30 √ó 41]&gt;\n##  4     4 &lt;RngdSmmE[,30]&gt; &lt;dbl [30 √ó 54]&gt;\n##  5     5 &lt;RngdSmmE[,30]&gt; &lt;dbl [30 √ó 44]&gt;\n##  6     6 &lt;RngdSmmE[,30]&gt; &lt;dbl [30 √ó 53]&gt;\n##  # ‚Ñπ 50 more rows\n\nWe fit an elastic net model (Friedman, Hastie, and Tibshirani 2010).\n\nFriedman, Jerome H., Trevor Hastie, and Rob Tibshirani. 2010. ‚ÄúRegularization Paths for Generalized Linear Models via Coordinate Descent.‚Äù Journal of Statistical Software 33 (1): 1‚Äì22. https://doi.org/10.18637/jss.v033.i01.\n\nlibrary(glmnet)\ny &lt;- colData(se)$time\nnested &lt;- nested |&gt;\n    mutate(fit = map(trainx, ~ {\n        glmnet(x = .x, y = y, alpha = .5, lambda = .1)\n    }))\nnested\n##  # A tibble: 56 √ó 4\n##     tile data            trainx          fit    \n##    &lt;int&gt; &lt;list&gt;          &lt;list&gt;          &lt;list&gt; \n##  1     1 &lt;RngdSmmE[,30]&gt; &lt;dbl [30 √ó 20]&gt; &lt;elnet&gt;\n##  2     2 &lt;RngdSmmE[,30]&gt; &lt;dbl [30 √ó 54]&gt; &lt;elnet&gt;\n##  3     3 &lt;RngdSmmE[,30]&gt; &lt;dbl [30 √ó 41]&gt; &lt;elnet&gt;\n##  4     4 &lt;RngdSmmE[,30]&gt; &lt;dbl [30 √ó 54]&gt; &lt;elnet&gt;\n##  5     5 &lt;RngdSmmE[,30]&gt; &lt;dbl [30 √ó 44]&gt; &lt;elnet&gt;\n##  6     6 &lt;RngdSmmE[,30]&gt; &lt;dbl [30 √ó 53]&gt; &lt;elnet&gt;\n##  # ‚Ñπ 50 more rows\n\nWe use the elastic net model, to predict the design from the gene expression (a variable number and set of genes per tile):\n\nnested &lt;- nested |&gt;\n    mutate(\n        pred = map2(trainx, fit, ~ {\n            predict(.y, newx = .x)[,1]\n        }),\n        n = map_dbl(data, nrow),\n        in_r2 = map_dbl(pred, ~ cor(.x, y)^2)\n    )\nnested\n##  # A tibble: 56 √ó 7\n##     tile data            trainx          fit     pred           n in_r2\n##    &lt;int&gt; &lt;list&gt;          &lt;list&gt;          &lt;list&gt;  &lt;list&gt;     &lt;dbl&gt; &lt;dbl&gt;\n##  1     1 &lt;RngdSmmE[,30]&gt; &lt;dbl [30 √ó 20]&gt; &lt;elnet&gt; &lt;dbl [30]&gt;    20 0.851\n##  2     2 &lt;RngdSmmE[,30]&gt; &lt;dbl [30 √ó 54]&gt; &lt;elnet&gt; &lt;dbl [30]&gt;    54 0.908\n##  3     3 &lt;RngdSmmE[,30]&gt; &lt;dbl [30 √ó 41]&gt; &lt;elnet&gt; &lt;dbl [30]&gt;    41 0.906\n##  4     4 &lt;RngdSmmE[,30]&gt; &lt;dbl [30 √ó 54]&gt; &lt;elnet&gt; &lt;dbl [30]&gt;    54 0.880\n##  5     5 &lt;RngdSmmE[,30]&gt; &lt;dbl [30 √ó 44]&gt; &lt;elnet&gt; &lt;dbl [30]&gt;    44 0.912\n##  6     6 &lt;RngdSmmE[,30]&gt; &lt;dbl [30 √ó 53]&gt; &lt;elnet&gt; &lt;dbl [30]&gt;    53 0.892\n##  # ‚Ñπ 50 more rows\n\nFinally we plot the prediction \\(R^2\\), and compare to the number of genes in the models:\n\nlibrary(ggplot2)\nggplot(nested, aes(n, in_r2)) +\n    geom_point() +\n    ylab(\"in-sample r2\")\n\n\n\n\n\n\n\nQuestions:\n\nHow else could we have performed the analysis, without doing the nesting operation? Would this have been faster? What other variables would need to be created to keep track of the many models?\nWhat advantages or disadvantages can you think about for the different ways of running multiple models across large genomic datasets?\n\n\n\n\n\n Back to top"
  },
  {
    "objectID": "pages/isoform-analysis.html",
    "href": "pages/isoform-analysis.html",
    "title": "\n9¬† Isoform analysis\n",
    "section": "",
    "text": "Objectives\n\n\n\n\nCompare the structure of isoforms within a gene using grouping and disjoin operations\n\n\n\nThere are many packages in Bioconductor that allow for isoform-level analysis across samples (also called transcript-level analysis). Packages that facilitate differential transcript analysis include DEXSeq and DRIMSeq (demonstrated in the rnaseqDTU workflow), and newer packages satuRn and fishpond.\nOnce you‚Äôve identified isoforms of interest within a gene, perhaps isoforms that switch in terms of their expression after cells are treated, one can use the IsoformSwitchAnalyzeR Bioconductor package to visualize and analyze a set of isoform switches (Vitting-Seerup and Sandelin 2019). For example, one can test the functional consequences of a set of isoform switches in terms of the gain or loss of protein domains, or splicing-centric changes (e.g. alternative 3‚Äô or 5‚Äô acceptor sites, alternative transcription start or ends sites, etc.) IsoformSwitchAnalyzeR is a multi-feature and mature package for this type of analysis, but we can perform some simpler within-gene isoform comparisons using plyranges, mostly for demonstration.\n\nVitting-Seerup, Kristoffer, and Albin Sandelin. 2019. ‚ÄúIsoformSwitchAnalyzeR: Analysis of Changes in Genome-Wide Patterns of Alternative Splicing and Its Functional Consequences.‚Äù Bioinformatics 35 (21): 4469‚Äì71.\nHere we will suppose that we have somehow identified isoforms of interest, and we want to compare these isoforms to other isoforms of the same gene. For simplicity, we will focus on one isoform per gene, for a particular set of interesting genes, just picking isoforms at random for genes on chr1. We could use plyranges to compare various metadata about isoforms or exons e.g.¬†RNA-seq or ChIP-seq coverage, sequence content, etc. But here we will just compare isoforms alone by the interval definitions. Then to reformulate:\nSpecific objective 1: compare one isoform per gene to the others, in terms of the extent from TSS to TES. What makes this isoform distinct?\nWe will start again with the transcript database we‚Äôve used before:\n\nlibrary(TxDb.Hsapiens.UCSC.hg19.knownGene)\ntxdb &lt;- TxDb.Hsapiens.UCSC.hg19.knownGene\ntxp &lt;- transcripts(txdb)\n\nFor further operations it will be convenient to have the tx_id be a character variable, and we filter now to a set of genes of interest (here just picking those on chr1):\n\nlibrary(plyranges)\ntxp &lt;- txp |&gt;\n    mutate(tx_id = as.character(tx_id)) |&gt;\n    filter(seqnames == \"chr1\")\n\nIt is sometimes useful to have other identifiers, such as the gene ID (Entrez)‚Ä¶\n\ntxp &lt;- txp |&gt;\n    mutate(\n        gene_id = mapIds(\n            txdb, keys=tx_id,\n            column=\"GENEID\", keytype=\"TXID\"\n        )\n    ) |&gt; filter(!is.na(gene_id))\n\n‚Ä¶and the gene symbol. For simplicity we will keep genes that have a non-NA symbol but this step is not necessary.\n\nlibrary(org.Hs.eg.db)\ntxp &lt;- txp |&gt;\n    mutate(\n        symbol = mapIds(\n            org.Hs.eg.db, keys=gene_id,\n            column=\"SYMBOL\", keytype=\"ENTREZID\"\n        )\n    ) |&gt;\n    filter(!is.na(symbol))\n\nThe following is one way to identify which isoforms belong to multi-isoform genes:\n\ntxp &lt;- txp |&gt;\n  group_by(gene_id) |&gt; \n  mutate(ntxp = plyranges::n()) |&gt;\n  ungroup()\n\nWe can now filter to the multi-isoform genes:\n\ntxp &lt;- txp |&gt;\n    filter(ntxp &gt; 1)\n\nHere we arbitrarily pick one isoform per gene, first by identifying those in a tibble‚Ä¶\n\nlibrary(tibble)\nset.seed(3)\npick_one &lt;- txp |&gt;\n    as_tibble() |&gt;\n    group_by(gene_id) |&gt;\n    slice(sample.int(n(), size=1)) |&gt;\n    dplyr::pull(tx_id)\n\n‚Ä¶then we can label these in our txp object. We will track these with an integer, 1 for the isoform of interest, and 0 for the others.\n\ntxp &lt;- txp |&gt;\n    mutate(the_one = as.integer(tx_id %in% pick_one))\n\nTo identify which ‚Äúparts‚Äù of the TSS-to-TES interval belong to which isoform, we can use disjoin_ranges. This breaks up the ranges, here grouped by gene, into distinct parts, and labels those according to whatever metadata variables we specify. Here we specify to combine tx_id into a collapsed string, but we could also perform numeric operations, e.g.¬†min or mean etc. And we can specify more than one new variable to be created during the disjoin_ranges operation. As with reduce_ranges, this operation can be _directed or not.\n\ntxp |&gt;\n    group_by(gene_id) |&gt;\n    disjoin_ranges(tx_ids = paste(tx_id,collapse=\",\"))\n##  GRanges object with 4438 ranges and 2 metadata columns:\n##           seqnames              ranges strand |     gene_id\n##              &lt;Rle&gt;           &lt;IRanges&gt;  &lt;Rle&gt; | &lt;character&gt;\n##       [1]     chr1         11874-14409      * |   100287102\n##       [2]     chr1       367659-368597      * |      729759\n##       [3]     chr1       621096-622034      * |      729759\n##       [4]     chr1       762971-763177      * |      643837\n##       [5]     chr1       763178-778984      * |      643837\n##       ...      ...                 ...    ... .         ...\n##    [4434]     chr1 249144203-249150234      * |       55657\n##    [4435]     chr1 249150235-249152264      * |       55657\n##    [4436]     chr1 249152265-249152912      * |       55657\n##    [4437]     chr1 249152913-249153125      * |       55657\n##    [4438]     chr1 249153126-249153315      * |       55657\n##                           tx_ids\n##                      &lt;character&gt;\n##       [1]                  1,2,3\n##       [2]                     11\n##       [3]                   4099\n##       [4]         14,15,16,17,18\n##       [5]      14,15,16,17,18,19\n##       ...                    ...\n##    [4434] 7962,7963,7964,7965,..\n##    [4435] 7963,7964,7965,7966,..\n##    [4436]    7964,7965,7966,7967\n##    [4437]         7965,7966,7967\n##    [4438]              7966,7967\n##    -------\n##    seqinfo: 93 sequences (1 circular) from hg19 genome\n\nHere we try to answer the specific objective, by labeling which parts belong exclusively to the isoform of interest by computing min(the_one) (try to convince yourself that this does in fact identify these intervals).\n\ntxp |&gt;\n    group_by(gene_id) |&gt;\n    disjoin_ranges(the_one_parts = min(the_one)) |&gt;\n    filter(the_one_parts &gt; 0)\n##  GRanges object with 257 ranges and 2 metadata columns:\n##          seqnames              ranges strand |     gene_id the_one_parts\n##             &lt;Rle&gt;           &lt;IRanges&gt;  &lt;Rle&gt; | &lt;character&gt;     &lt;integer&gt;\n##      [1]     chr1       621096-622034      * |      729759             1\n##      [2]     chr1     2407754-2411622      * |        9651             1\n##      [3]     chr1     2495189-2495267      * |        8764             1\n##      [4]     chr1     3689334-3689351      * |      388588             1\n##      [5]     chr1     6268367-6268677      * |      388591             1\n##      ...      ...                 ...    ... .         ...           ...\n##    [253]     chr1 243651535-243663020      * |       10000             1\n##    [254]     chr1 244571794-244586136      * |         159             1\n##    [255]     chr1 246580715-246670644      * |       64754             1\n##    [256]     chr1 247492918-247495045      * |       84838             1\n##    [257]     chr1 249119835-249120154      * |       80851             1\n##    -------\n##    seqinfo: 93 sequences (1 circular) from hg19 genome\n\nDo the parts identified make sense if we check one gene?\n\ntxp |&gt;\n    filter(gene_id == \"9651\")\n##  GRanges object with 6 ranges and 6 metadata columns:\n##        seqnames          ranges strand |       tx_id     tx_name     gene_id\n##           &lt;Rle&gt;       &lt;IRanges&gt;  &lt;Rle&gt; | &lt;character&gt; &lt;character&gt; &lt;character&gt;\n##    [1]     chr1 2407754-2436964      + |         134  uc001aji.1        9651\n##    [2]     chr1 2411623-2436892      + |         135  uc010nyz.2        9651\n##    [3]     chr1 2411623-2436964      + |         136  uc009vle.1        9651\n##    [4]     chr1 2411623-2436965      + |         137  uc001ajj.1        9651\n##    [5]     chr1 2411623-2436969      + |         138  uc001ajk.1        9651\n##    [6]     chr1 2430183-2436964      + |         139  uc001ajl.1        9651\n##             symbol      ntxp   the_one\n##        &lt;character&gt; &lt;integer&gt; &lt;integer&gt;\n##    [1]       PLCH2         6         1\n##    [2]       PLCH2         6         0\n##    [3]       PLCH2         6         0\n##    [4]       PLCH2         6         0\n##    [5]       PLCH2         6         0\n##    [6]       PLCH2         6         0\n##    -------\n##    seqinfo: 93 sequences (1 circular) from hg19 genome\n\nLet‚Äôs pause and consider what we‚Äôve answered so far. We asked, for a given isoform per gene, what parts (intervals) uniquely define that isoform, when we just consider TSS-to-TES extent (ignoring the exonic/intronic structure). We started here mostly for simplicity, but typically we care about transcribed sequence, so let‚Äôs repeat this task, now considering what exonic parts are unique to one isoform per gene.\nSpecific objective 2: compare one isoform per gene to the others, in terms of the exonic intervals. What makes this isoform distinct?\nTo start, we will need a list of the exons, grouped by transcript.\n\nebt &lt;- exonsBy(txdb, by=\"tx\")\nebt &lt;- ebt[txp$tx_id] # subset to those txp/genes of interest\n\nHere, we could have also used bind_ranges but I find that for very large lists of ranges, unlist is faster:\n\nexons &lt;- unlist(ebt) |&gt;\n    select(exon_id, exon_rank) |&gt;\n    mutate(tx_id = rep(names(ebt), lengths(ebt)))\nexons\n##  GRanges object with 67595 ranges and 3 metadata columns:\n##         seqnames              ranges strand |   exon_id exon_rank       tx_id\n##            &lt;Rle&gt;           &lt;IRanges&gt;  &lt;Rle&gt; | &lt;integer&gt; &lt;integer&gt; &lt;character&gt;\n##       1     chr1         11874-12227      + |         1         1           1\n##       1     chr1         12613-12721      + |         3         2           1\n##       1     chr1         13221-14409      + |         5         3           1\n##       2     chr1         11874-12227      + |         1         1           2\n##       2     chr1         12595-12721      + |         2         2           2\n##     ...      ...                 ...    ... .       ...       ...         ...\n##    7967     chr1 249149757-249149834      - |     27460         7        7967\n##    7967     chr1 249149579-249149657      - |     27459         8        7967\n##    7967     chr1 249148136-249148250      - |     27458         9        7967\n##    7967     chr1 249144881-249144980      - |     27457        10        7967\n##    7967     chr1 249144203-249144715      - |     27456        11        7967\n##    -------\n##    seqinfo: 93 sequences (1 circular) from hg19 genome\n\nThe exons ranges are missing some of our key metadata from txp. We can add this, by first select-ing what we want from txp, turning this into a tibble and left_join-ing to the exons. I add an all.equal step to make sure we have the two tables lined up, before we add the extra columns with cbind.\nSome of this code wouldn‚Äôt be necessary for TranscriptDb with more details exons output, as with ensembldb.\n\ntxp_data &lt;- txp |&gt;\n    select(tx_id, gene_id, ntxp, the_one, .drop_ranges=TRUE) |&gt;\n    as_tibble()\nids &lt;- dplyr::left_join(\n    tibble(tx_id = exons$tx_id),\n    txp_data,\n    by=\"tx_id\"\n)\nids\n##  # A tibble: 67,595 √ó 4\n##    tx_id gene_id    ntxp the_one\n##    &lt;chr&gt; &lt;chr&gt;     &lt;int&gt;   &lt;int&gt;\n##  1 1     100287102     3       1\n##  2 1     100287102     3       1\n##  3 1     100287102     3       1\n##  4 2     100287102     3       0\n##  5 2     100287102     3       0\n##  6 2     100287102     3       0\n##  # ‚Ñπ 67,589 more rows\nall.equal(exons$tx_id, ids$tx_id)\n##  [1] TRUE\nmcols(exons) &lt;- cbind(mcols(exons), ids |&gt; select(-tx_id))\nexons\n##  GRanges object with 67595 ranges and 6 metadata columns:\n##         seqnames              ranges strand |   exon_id exon_rank       tx_id\n##            &lt;Rle&gt;           &lt;IRanges&gt;  &lt;Rle&gt; | &lt;integer&gt; &lt;integer&gt; &lt;character&gt;\n##       1     chr1         11874-12227      + |         1         1           1\n##       1     chr1         12613-12721      + |         3         2           1\n##       1     chr1         13221-14409      + |         5         3           1\n##       2     chr1         11874-12227      + |         1         1           2\n##       2     chr1         12595-12721      + |         2         2           2\n##     ...      ...                 ...    ... .       ...       ...         ...\n##    7967     chr1 249149757-249149834      - |     27460         7        7967\n##    7967     chr1 249149579-249149657      - |     27459         8        7967\n##    7967     chr1 249148136-249148250      - |     27458         9        7967\n##    7967     chr1 249144881-249144980      - |     27457        10        7967\n##    7967     chr1 249144203-249144715      - |     27456        11        7967\n##             gene_id      ntxp   the_one\n##         &lt;character&gt; &lt;integer&gt; &lt;integer&gt;\n##       1   100287102         3         1\n##       1   100287102         3         1\n##       1   100287102         3         1\n##       2   100287102         3         0\n##       2   100287102         3         0\n##     ...         ...       ...       ...\n##    7967       55657         6         0\n##    7967       55657         6         0\n##    7967       55657         6         0\n##    7967       55657         6         0\n##    7967       55657         6         0\n##    -------\n##    seqinfo: 93 sequences (1 circular) from hg19 genome\n\nWe repeat similar code as performed above with txp, now identifying parts of exons that are unique to the isoform of interest, per gene:\n\nexon_parts &lt;- exons |&gt;\n    group_by(gene_id) |&gt;\n    disjoin_ranges(the_one_parts = min(the_one)) |&gt;\n    filter(the_one_parts &gt; 0)\nexon_parts\n##  GRanges object with 1604 ranges and 2 metadata columns:\n##           seqnames              ranges strand |     gene_id the_one_parts\n##              &lt;Rle&gt;           &lt;IRanges&gt;  &lt;Rle&gt; | &lt;character&gt;     &lt;integer&gt;\n##       [1]     chr1       621096-622034      * |      729759             1\n##       [2]     chr1       776580-778984      * |      643837             1\n##       [3]     chr1       898412-898488      * |      339451             1\n##       [4]     chr1       898634-898716      * |      339451             1\n##       [5]     chr1       898885-899229      * |      339451             1\n##       ...      ...                 ...    ... .         ...           ...\n##    [1600]     chr1 247301447-247302017      * |        7678             1\n##    [1601]     chr1 247493268-247493383      * |       84838             1\n##    [1602]     chr1 247494734-247495045      * |       84838             1\n##    [1603]     chr1 249120034-249120154      * |       80851             1\n##    [1604]     chr1 249152521-249152710      * |       55657             1\n##    -------\n##    seqinfo: 93 sequences (1 circular) from hg19 genome\n\nTo confirm that we‚Äôve identified the right parts, let‚Äôs use plotgardener to visualize a particular gene:\n\ntxp |&gt;\n    filter(gene_id == \"339451\")\n##  GRanges object with 5 ranges and 6 metadata columns:\n##        seqnames        ranges strand |       tx_id     tx_name     gene_id\n##           &lt;Rle&gt;     &lt;IRanges&gt;  &lt;Rle&gt; | &lt;character&gt; &lt;character&gt; &lt;character&gt;\n##    [1]     chr1 895967-901099      + |          55  uc001aca.2      339451\n##    [2]     chr1 896829-897858      + |          56  uc001acb.1      339451\n##    [3]     chr1 897009-897858      + |          57  uc010nya.1      339451\n##    [4]     chr1 897461-901099      + |          58  uc001acc.2      339451\n##    [5]     chr1 897735-899229      + |          59  uc010nyb.1      339451\n##             symbol      ntxp   the_one\n##        &lt;character&gt; &lt;integer&gt; &lt;integer&gt;\n##    [1]      KLHL17         5         0\n##    [2]      KLHL17         5         0\n##    [3]      KLHL17         5         0\n##    [4]      KLHL17         5         0\n##    [5]      KLHL17         5         1\n##    -------\n##    seqinfo: 93 sequences (1 circular) from hg19 genome\ntx_to_show &lt;- txp |&gt;\n    filter(gene_id == \"339451\" & the_one == 1) |&gt;\n    as_tibble() |&gt;\n    dplyr::pull(tx_name)\nthese_parts &lt;- exon_parts |&gt;\n    filter(gene_id == \"339451\")\n\nWe lay out a page zooming into this gene and its isoforms:\n\nlibrary(plotgardener)\npar &lt;- pgParams(\n    chrom = \"chr1\", \n    chromstart = 895.9e3, chromend = 901.2e3,\n    assembly = \"hg19\", just = c(\"left\", \"bottom\")\n)\n\nWe will highlight our isoform of interest:\n\nhilite &lt;- data.frame(transcript=tx_to_show, color=\"magenta\")\n\nFinally, putting it all together:\n\npageCreate(width = 5, height = 2.5, showGuides = FALSE)\nplotTranscripts(\n    params = par, x = 0.5, y = 1.5, width = 4, height = 1.5,\n    transcriptHighlights = hilite\n)\nplotRanges(\n    these_parts, fill=\"darkorchid\",\n    params = par, x = 0.5, y = 1.75, width = 4, height = .25\n)\nlabel &lt;- paste(\"unique parts of\", tx_to_show)\nplotText(\n    label = label, fontcolor = \"darkorchid\",\n    params = par, x = 3.1, y = 1.75,\n    just = c(\"left\", \"bottom\"), fontsize = 8\n)\nplotGenomeLabel(\n    params = par, x = 0.5, y = 2, length = 4,\n    just = c(\"left\", \"top\")\n)\n\n\n\n\n\n\n\nQuestions:\n\nHow else could we have found parts of one isoform per gene, that do not belong to any other isoforms of the genes. Would other approaches have any limitations?\n\n\n\n\n\n Back to top"
  },
  {
    "objectID": "pages/tximeta-gene-range.html",
    "href": "pages/tximeta-gene-range.html",
    "title": "\n10¬† Gene ranges in tximeta\n",
    "section": "",
    "text": "Objectives\n\n\n\n\nExplore how genes are located in the genome during summarization with tximeta\n\n\n\n\n\n\n\n\n\nThis version requires features from the tximport package implemented in Bioconductor 3.18 (current devel).\n\n\n\n\n\n\nThe tximeta package (Love et al. 2020) imports gene expression quantification into Bioconductor. The package is built around a few main ideas:\n\ntranscript-level quantification improves accuracy even for gene-level inference (Soneson, Love, and Robinson 2015)\n\nsummarization to gene level is a common use case\nreference sequence hashes (think of a ‚Äúbarcode‚Äù that uniquely identifies the cDNA sequences) can be used to identify the provenance and release information of annotation\n\n\nSoneson, Charlotte, Michael I. Love, and Mark Robinson. 2015. ‚ÄúDifferential analyses for RNA-seq: transcript-level estimates improve gene-level inferences.‚Äù F1000Research 4. https://doi.org/10.12688/f1000research.7563.1.\n\nPatro, Rob, Geet Duggal, Michael I. Love, Rafael A. Irizarry, and Carl Kingsford. 2017. ‚ÄúSalmon Provides Fast and Bias-Aware Quantification of Transcript Expression.‚Äù Nature Methods. https://doi.org/10.1038/nmeth.4197.\n\nLove, Michael I., Charlotte Soneson, Peter F. Hickey, Lisa K. Johnson, N. Tessa Pierce, Lori Shepherd, Martin Morgan, and Rob Patro. 2020. ‚ÄúTximeta: Reference sequence checksums for provenance identification in RNA-seq.‚Äù PLOS Computational Biology 16: e1007664. https://doi.org/10.1371/journal.pcbi.1007664.\ntximeta uses reference sequence hashes embedded in metadata files provided with Salmon (Patro et al. 2017) quantification output to automatically attach genomic range information, transcript-to-gene mapping, and genome build information to SummarizedExperiments. This is done automatically, on behalf of the user, without needing to specify the provenance or release numbers used during quantification. tximeta can also be used in combination with de novo transcriptomes or less common transcriptomes (see Love et al. (2020) or package vignette).\nWhen data is summarized to the gene level, tximeta by default uses the genes() function to locate the genes in the genome. This provides a genomic range which starts with the leftmost position of any isoform and ends with the rightmost position of any isoform. This however may not be a good representation of the locus of transcription.\nIn this chapter, we explore an alternative way to assign ranges in tximeta‚Äôs summarization step, which is based on isoform abundance. We use plyranges and plotgardener packages to explore the differences between these two options for range assignment.\nData description: the macrophage package provides Salmon quantification files for a set of 24 RNA-seq samples from Alasoo et al. (2018). Data for six female human donors is available in the package, with gene expression at baseline, after IFN-gamma stimulation, after exposure to Salmonella, and after a combination of the two treatments. We won‚Äôt focus on the design of the experiment itself, but we will use transcript-level quantification data to explore the differences between the two range assignment options.\n\nAlasoo, Kaur, Julia Rodrigues, Subhankar Mukhopadhyay, Andrew J. Knights, Alice L. Mann, Kousik Kundu, Christine Hale, Gordon Dougan, Daniel J. Gaffney, and H. I. P. S. C. I. Consortium. 2018. ‚ÄúShared Genetic Effects on Chromatin and Gene Expression Indicate a Role for Enhancer Priming in Immune Response.‚Äù Nature Genetics 50 (3): 424‚Äì31. https://doi.org/10.1038/s41588-018-0046-7.\nThe following code chunk creates a coldata table describing the samples.\n\nlibrary(macrophage)\nlibrary(dplyr)\nlibrary(tximeta)\ndir &lt;- system.file(\"extdata\", package=\"macrophage\")\ncoldata &lt;- read.csv(file.path(dir, \"coldata.csv\")) |&gt;\n    mutate(\n        files = file.path(dir, \"quants\", names, \"quant.sf.gz\"),\n        condition = factor(condition_name),\n        condition = relevel(condition, \"naive\")\n    ) |&gt;\n    select(files, names=sample_id, condition, line_id) |&gt;\n    slice(1:4) # subset to a few samples\ncoldata |&gt;\n    dplyr::select(-files)\n##     names   condition line_id\n##  1 diku_A       naive  diku_1\n##  2 diku_B        IFNg  diku_1\n##  3 diku_C      SL1344  diku_1\n##  4 diku_D IFNg_SL1344  diku_1\n\nImporting the transcript-level data as a SummarizedExperiment:\n\nse &lt;- tximeta(coldata, dropInfReps=TRUE)\n\nWe can then see the ranges of the transcripts and the genome build information:\n\nlibrary(SummarizedExperiment)\nrowRanges(se)\n##  GRanges object with 205870 ranges and 3 metadata columns:\n##                      seqnames      ranges strand |     tx_id\n##                         &lt;Rle&gt;   &lt;IRanges&gt;  &lt;Rle&gt; | &lt;integer&gt;\n##    ENST00000456328.2     chr1 11869-14409      + |         1\n##    ENST00000450305.2     chr1 12010-13670      + |         2\n##    ENST00000488147.1     chr1 14404-29570      - |      9483\n##    ENST00000619216.1     chr1 17369-17436      - |      9484\n##    ENST00000473358.1     chr1 29554-31097      + |         3\n##                  ...      ...         ...    ... .       ...\n##    ENST00000361681.2     chrM 14149-14673      - |    206692\n##    ENST00000387459.1     chrM 14674-14742      - |    206693\n##    ENST00000361789.2     chrM 14747-15887      + |    206684\n##    ENST00000387460.2     chrM 15888-15953      + |    206685\n##    ENST00000387461.2     chrM 15956-16023      - |    206694\n##                                gene_id           tx_name\n##                        &lt;CharacterList&gt;       &lt;character&gt;\n##    ENST00000456328.2 ENSG00000223972.5 ENST00000456328.2\n##    ENST00000450305.2 ENSG00000223972.5 ENST00000450305.2\n##    ENST00000488147.1 ENSG00000227232.5 ENST00000488147.1\n##    ENST00000619216.1 ENSG00000278267.1 ENST00000619216.1\n##    ENST00000473358.1 ENSG00000243485.5 ENST00000473358.1\n##                  ...               ...               ...\n##    ENST00000361681.2 ENSG00000198695.2 ENST00000361681.2\n##    ENST00000387459.1 ENSG00000210194.1 ENST00000387459.1\n##    ENST00000361789.2 ENSG00000198727.2 ENST00000361789.2\n##    ENST00000387460.2 ENSG00000210195.2 ENST00000387460.2\n##    ENST00000387461.2 ENSG00000210196.2 ENST00000387461.2\n##    -------\n##    seqinfo: 25 sequences (1 circular) from hg38 genome\nseqinfo(se)\n##  Seqinfo object with 25 sequences (1 circular) from hg38 genome:\n##    seqnames seqlengths isCircular genome\n##    chr1      248956422      FALSE   hg38\n##    chr2      242193529      FALSE   hg38\n##    chr3      198295559      FALSE   hg38\n##    chr4      190214555      FALSE   hg38\n##    chr5      181538259      FALSE   hg38\n##    ...             ...        ...    ...\n##    chr21      46709983      FALSE   hg38\n##    chr22      50818468      FALSE   hg38\n##    chrX      156040895      FALSE   hg38\n##    chrY       57227415      FALSE   hg38\n##    chrM          16569       TRUE   hg38\n\nThe default approach to assign ranges during summarization (rowRanges will represent the total extent of all isoforms of the gene):\n\ngse_default &lt;- summarizeToGene(se)\n##  loading existing TxDb created: 2023-08-12 17:14:11\n##  obtaining transcript-to-gene mapping from database\n##  generating gene ranges\n##  gene ranges assigned by total range of isoforms, see `assignRanges`\n##  summarizing abundance\n##  summarizing counts\n##  summarizing length\n\nAnd an alternative method to assign ranges by isoform abundance (rowRanges will represent the extent of the most abundant isoform):\n\ngse &lt;- summarizeToGene(se, assignRanges=\"abundant\")\n##  loading existing TxDb created: 2023-08-12 17:14:11\n##  obtaining transcript-to-gene mapping from database\n##  loading existing gene ranges created: 2023-08-12 17:14:19\n##  gene ranges assigned by isoform abundance, see `assignRanges`\n##  summarizing abundance\n##  summarizing counts\n##  summarizing length\n\nNote that these two steps provide identical counts, abundance, etc. They only differ by their rowRanges.\n\nall.equal(assay(gse_default), assay(gse))\n##  [1] TRUE\n\nWe can now compare the 5‚Äô location of the ranges using the two approaches.\n\nlibrary(plyranges)\ndefault_5p &lt;- gse_default |&gt;\n    rowRanges() |&gt;\n    anchor_5p() |&gt;\n    mutate(width=1) |&gt;\n    start()\n\nPull out information from the SummarizedExperiment: the average abundance over the samples, and the absolute distance between the 5‚Äô start of the new and the old approach.\n\ngene_dat &lt;- gse |&gt;\n    rowRanges() |&gt;\n    anchor_5p() |&gt;\n    mutate(width=1) |&gt;\n    mutate(\n        ave_tpm = rowMeans(assay(gse, \"abundance\")),\n        dist = abs(start - default_5p)\n    )\n# how many genes have same 5' start?\ntable(gene_dat$dist == 0)\n##  \n##  FALSE  TRUE \n##  11775 46519\n\nWhile most genes have the same 5‚Äô start, a good number have changed their start position.\nWe can summarize the extent of changes by gene expression:\n\nlibrary(ggplot2)\ngene_dat |&gt;\n    as_tibble() |&gt;\n    filter(dist &gt; 0) |&gt;\n    mutate(\n        log10_dist = cut(\n            log10(dist),\n            breaks=c(0,3:6,Inf),\n            include.lowest=TRUE\n        ),\n        tpm = cut(\n            ave_tpm,\n            breaks=c(0,1,10,100,Inf),\n            include.lowest=TRUE\n        )\n    ) |&gt;\n    group_by(log10_dist, tpm) |&gt;\n    tally() |&gt;\n    ggplot(aes(log10_dist, n)) +\n    geom_col() +\n    ggtitle(\"change in 5' position of gene\") +\n    ylab(\"number of genes\") +\n    facet_wrap(~tpm, labeller=label_both)\n\n\n\n\n\n\n\nConsiderations:\n\nThe isoform-abundance based representation of the gene is likely a much more accurate description of the locus of transcription than the total gene extent.\nThe isoform-abundance 5‚Äô start can be very far away from the total gene extent 5‚Äô start.\nGene-level summary is an incomplete representation of transcription, and perhaps it may be better to perform analysis on the transcript level, e.g.¬†DTE (see swish in fishpond package or catchSalmon/catchKallisto in edgeR) or DTU (see DEXSeq, satuRn, diffSplice in limma package, Segers et al. (2023), or the rnaseqDTU workflow).\n\n\nSegers, Alexandre, Jeroen Gilis, Mattias Van Heetvelde, Elfride De Baere, and Lieven Clement. 2023. ‚ÄúJuggling Offsets Unlocks RNA-Seq Tools for Fast Scalable Differential Usage, Aberrant Splicing and Expression Analyses.‚Äù bioRxiv. https://doi.org/10.1101/2023.06.29.547014.\n\nKramer, Nicole E, Eric S Davis, Craig D Wenger, Erika M Deoudes, Sarah M Parker, Michael I Love, and Douglas H Phanstiel. 2022. ‚ÄúPlotgardener: cultivating precise multi-panel figures in R.‚Äù Bioinformatics 38 (7): 2042‚Äì45. https://doi.org/10.1093/bioinformatics/btac057.\nWe conclude this chapter by diagramming the difference between the two approaches for a single gene, using plotgardener (Kramer et al. 2022).\nWe begin by building a custom genome assembly for plotgardener functions. Note the use of tximeta::retrieveDb to pull the exact TxDb used in quantification of the data for representation of the ranges in the plots.\n\nlibrary(plotgardener)\nlibrary(org.Hs.eg.db)\n# retrieves the correct TxDb/EnsDb for use in plots, etc.\ntxdb &lt;- retrieveDb(gse)\nnew_assembly &lt;- assembly(\n    Genome = \"hg38\",\n    TxDb = txdb,\n    OrgDb = org.Hs.eg.db,\n    gene.id.column = \"GENEID\",\n    display.column = \"GENEID\",\n    BSgenome = NULL\n)\n\nWe pick a random gene with a large distance and high expression:\n\nset.seed(5)\ngene &lt;- gene_dat |&gt;\n    filter(strand == \"-\", dist &gt; 1e5, ave_tpm &gt; 100) |&gt;\n    slice(sample(plyranges::n(),1))\n\nThe following sets up the parameters for the following plotgardener command.\n\npar &lt;- pgParams(\n    chrom = seqnames(gene) |&gt; as.character(),\n    chromstart = round((start(gene) - 5e5) / 1e5) * 1e5,\n    chromend = round((end(gene) + 5e5) / 1e5) * 1e5,\n    assembly = new_assembly,\n    just = c(\"left\", \"bottom\")\n)\n\nExamine the isoform proportions for the top 5 isoforms of this gene:\n\nprops &lt;- gene$iso_prop[[1]] |&gt;\n    sort(decreasing=TRUE) |&gt;\n    head(5)\nprops\n##  ENST00000542652.6 ENST00000540638.6 ENST00000544123.5 ENST00000584651.5 \n##         0.35557166        0.31174119        0.07755495        0.06530776 \n##  ENST00000581292.5 \n##         0.03857342\n\nHighlight the gene, and the top 5 isoforms in the following plot.\n\ngene_hilite &lt;- data.frame(\n    gene=gene$gene_id,\n    color=\"magenta\"\n)\ntxp_hilite &lt;- data.frame(\n    transcript=names(props),\n    color=rep(c(\"dodgerblue\",\"darkgoldenrod\"),c(1,length(props)-1))\n)\n\nBuilding the plotgardener plot:\n\npageCreate(width = 5, height = 4, showGuides = FALSE)\nplotGenes(\n    params = par, x = 0.5, y = 3.5, width = 4, height = 1,\n    geneHighlights = gene_hilite\n)\nplotTranscripts(\n    params = par, x = 0.5, y = 2.5, width = 4, height = 2.5,\n    transcriptHighlights = txp_hilite, fill=\"grey90\"\n)\n##  Warning: Not enough plotting space for all provided elements. ('+' indicates\n##  elements not shown.)\nplotGenomeLabel(\n    params = par, x = 0.5, y = 3.5, length = 4,\n    just = c(\"left\", \"top\")\n)\n\n\n\n\n\n\n\n\n\n\n\n Back to top"
  }
]